<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>solidSpoon's Blog</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #ffffff;
            color: #24292f;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
    
        /* 导航栏样式 */
        .site-header {
            background-color: #ffffff;
            border-bottom: 1px solid #d0d7de;
            padding: 20px 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
        }
    
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
    
        .nav-brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 22px;
            font-weight: 600;
            color: #24292f;
            text-decoration: none;
            transition: color 0.2s ease;
        }
    
        .nav-brand:hover {
            color: #0969da;
        }
    
        .github-avatar {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            transition: transform 0.2s ease;
        }
    
        .github-avatar:hover {
            transform: scale(1.1);
        }
    
        .github-link {
            display: flex;
            align-items: center;
            color: #57606a;
            transition: color 0.2s ease;
        }
    
        .github-link:hover {
            color: #0969da;
        }
    
        .nav-links {
            display: flex;
            gap: 24px;
        }
    
        .nav-link {
            color: #57606a;
            text-decoration: none;
            font-size: 14px;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
    
        .nav-link:hover {
            color: #24292f;
            background-color: #f6f8fa;
        }
    
        /* 主要内容区域 */
        .main-content {
            flex: 1;
            width: 100%;
            box-sizing: border-box;
        }
    
        /* 首页特定样式 */
        .main-content>.header {
            text-align: left;
            margin-bottom: 48px;
            padding: 48px 20px 32px;
            border-bottom: 1px solid #d0d7de;
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
        }
    
        .main-content>.search-container,
        .main-content>.posts {
            max-width: 900px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 20px;
        }
    
        .header h1 {
            margin: 0;
            font-size: 36px;
            font-weight: 600;
            color: #24292f;
            letter-spacing: -0.5px;
        }
    
        .header .motto {
            color: #57606a;
            margin-top: 12px;
            font-size: 18px;
            font-style: italic;
        }
    
        .header .description {
            color: #57606a;
            margin-top: 18px;
            font-size: 16px;
            max-width: 650px;
            line-height: 1.6;
        }
    
        /* 文章列表样式 */
        .post-item {
            margin-bottom: 24px;
            padding: 24px;
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 8px;
            transition: all 0.25s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
    
        .post-item:hover {
            border-color: #0969da;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-2px);
        }
    
        .post-item h2 {
            margin: 0 0 12px 0;
            font-size: 22px;
            font-weight: 600;
            color: #24292f;
            letter-spacing: -0.3px;
        }
    
        .post-date {
            color: #57606a;
            font-size: 14px;
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }
    
        .post-date::before {
            content: "";
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 8px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='%2357606a' d='M8 0a8 8 0 1 0 8 8 8 8 0 0 0-8-8zm0 14a6 6 0 1 1 6-6 6 6 0 0 1-6 6zm.5-10.5a.5.5 0 0 0-1 0v3.5a.5.5 0 0 0 .5.5h3a.5.5 0 0 0 0-1H8.5V3.5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
        }
    
        .excerpt {
            color: #57606a;
            font-size: 16px;
            line-height: 1.6;
            margin-top: 12px;
        }
    
        /* 链接样式 */
        a {
            color: #0969da;
            text-decoration: none;
            transition: color 0.2s ease;
        }
    
        a:hover {
            text-decoration: underline;
            color: #0550ae;
        }
    
        /* 文章内容样式 */
        .post-content {
            font-size: 16px;
            line-height: 1.6;
            color: #24292f;
        }
    
        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 32px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
            letter-spacing: -0.4px;
            color: #24292f;
        }
    
        .post-content h1 {
            font-size: 2em;
            border-bottom: 1px solid #d0d7de;
            padding-bottom: 0.3em;
        }
    
        .post-content h2 {
            font-size: 1.5em;
            border-bottom: 1px solid #d0d7de;
            padding-bottom: 0.3em;
        }
    
        .post-content p {
            margin-bottom: 20px;
            color: #24292f;
        }
    
        .post-content code {
            font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            border-radius: 6px;
            background-color: rgba(175, 184, 193, 0.2);
            color: #24292f;
        }
    
        .post-content pre {
            margin-bottom: 16px;
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
            border: 1px solid #d0d7de;
        }
    
        .post-content pre code {
            padding: 0;
            margin: 0;
            background-color: transparent;
            border: 0;
            white-space: pre;
            word-break: normal;
            overflow: visible;
            line-height: inherit;
            color: #24292f;
        }
    
        .post-content img {
            max-width: 100%;
            height: auto;
            border-style: none;
            box-sizing: content-box;
            border-radius: 6px;
        }
    
        .post-content ul,
        .post-content ol {
            margin-top: 0;
            margin-bottom: 16px;
            padding-left: 2em;
            color: #24292f;
        }
    
        .post-content blockquote {
            margin: 0 0 16px;
            padding: 0 1em;
            color: #57606a;
            border-left: 0.25em solid #d0d7de;
        }
    
        .post-content table {
            border-spacing: 0;
            border-collapse: collapse;
            margin-bottom: 16px;
            width: 100%;
        }
    
        .post-content table th,
        .post-content table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
    
        .post-content table tr {
            background-color: #ffffff;
            border-top: 1px solid #d0d7de;
        }
    
        .post-content table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
    
        /* 搜索框样式 */
        .search-container {
            margin-bottom: 32px;
            position: relative;
            max-width: 100%;
            box-sizing: border-box;
        }
    
        .search-input {
            width: 100%;
            padding: 12px 16px;
            font-size: 16px;
            border: 1px solid #d0d7de;
            border-radius: 8px;
            background-color: #ffffff;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
    
        .search-input:focus {
            outline: none;
            border-color: #0969da;
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.15);
        }
    
        .search-results {
            margin-top: 16px;
        }
    
        .no-results {
            text-align: center;
            color: #57606a;
            padding: 24px;
        }
    
        .highlight {
            background-color: #fff8c5;
            padding: 0 2px;
            border-radius: 2px;
        }
    
        /* 页脚样式 */
        .blog-footer {
            background-color: #f6f8fa;
            border-top: 1px solid #d0d7de;
            padding: 32px 16px;
            margin-top: 48px;
            text-align: center;
        }
    
        .footer-content {
            max-width: 900px;
            margin: 0 auto;
        }
    
        .footer-motto {
            color: #8b949e;
            font-size: 14px;
            margin: 0;
        }
    
    
        /* 搜索高亮样式 */
        .post-item.search-highlight {
            border-left: 4px solid #0969da;
            border-left-color: #0969da !important;
            background-color: #f8fafc;
        }
    
        .post-item.search-highlight h2 a {
            color: #0969da;
        }
    
        .search-highlight {
            animation: highlight-pulse 1.2s ease-in-out;
        }
    
        @keyframes highlight-pulse {
            0% {
                background-color: rgba(9, 105, 218, 0.15);
            }
    
            50% {
                background-color: rgba(9, 105, 218, 0.25);
            }
    
            100% {
                background-color: #f8fafc;
            }
        }
    
        /* 响应式调整 */
        @media (max-width: 768px) {
    
            .main-content>.header,
            .main-content>.search-container,
            .main-content>.posts {
                padding: 0 15px;
            }
    
            .post-item {
                padding: 16px;
            }
    
            .header h1 {
                font-size: 28px;
            }
    
            .header .motto {
                font-size: 16px;
            }
        }
    </style></head>

<body>
    <header class="site-header">
        <nav class="nav-container">
            <a href="index.html" class="nav-brand">
                <img src="https://github.com/solidSpoon.png" alt="GitHub Avatar" class="github-avatar" />
                solidSpoon
            </a>
            <a href="https://github.com/solidSpoon" class="github-link" target="_blank" rel="noopener noreferrer">
                <svg height="24" width="24" viewBox="0 0 16 16" fill="currentColor">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
        </nav>
    </header>
    <div class="main-content">
        <div class="header">
            <h1>solidSpoon</h1>
            <div class="motto">方向是比速度更重要的追求</div>
            <div class="description">
                这里是我的个人博客，记录技术、生活和思考。欢迎交流讨论。
            </div>
        </div>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="搜索文章..." id="searchInput">
        </div>
        <div class="posts" id="postsContainer">
            <div class="post-item" data-title="夏令时" data-content="举例 2018年3月11日02:00之后直接跳到03:00 - 如果应用试图表示一个发生在2:30 AM的事件，该本地时间在当天根本无效。 2018年11月4日凌晨时钟从02:00倒退回01:00 - 1点到2点这一小时发生了两次 - 一次为夏令时的EDT时区，一次为冬令时的EST时区 切换规则 在3月的第二个星期天，美国东部时间凌晨2:00，时钟提前至美国东部时间凌晨3:00，留下一小时的间隙。 在11月的第一个星期日（美国东部时间）凌晨 2:00，时钟会移回美国东部时间凌晨1:00，这会导致重复一个小时。 名词解释 DST: Daylight saving time 夏令时 ET：美国东部时间（The Eastern Time Zone）分为两个部分： - EST：东部标准时间（Eastern Standard Time, EST）比[协调世界时](https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6 &quot;协调世界时&quot;) (UTC) 晚5小时。 - EDT：东部夏令时间（Eastern Daylight Time, EDT）在使用[夏令时](https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6 &quot;夏时制&quot;)之时比协调世界时晚四个小时。">
                <h2><a href="xia-ling-shi.html">夏令时</a></h2>
                <div class="post-date">2025-03</div>
                <div class="excerpt">举例

2018年3月11日02:00之后直接跳到03:00
- 如果应用试图表示一个发生在2:30 AM的事件，该本地时间在当天根本无效。

2018年11月4日凌晨时钟从02:00倒退回01:00
- 1点到2点这一小时发生了两次
- 一次为夏令时的EDT时区，一次为冬令时的EST时区

 切换规则

在3月的第二个星期天，美国东部时间凌晨2:00，时钟提前至美国东部时间凌晨3:00，留下一小...</div>
            </div>
            <div class="post-item" data-title="AI 是如何学会聊天的" data-content="本文详细介绍了 AI 聊天模型的学习过程，从获取语料库、文本分词、预训练模型，到如何将基础模型转变为能够对话的 Chat 模型。同时讨论了上下文理解、模型幻觉等关键概念，以及如何通过搜索功能来增强模型的实时性和准确性。 获取语料库 在训练一个AI模型之前，首先需要准备大量的“语料”——即各种文本数据。这些文本数据来源于互联网上的网页、书籍、文章、社交媒体等。可以将这些数据看作是为AI模型提供的“学习材料库”，它将从这些材料中学习语言和知识。 例如，下面这个语料库从互联网抓取了51.3 TB（太字节）的文本数据。虽然这一数据量庞大，但它仅仅是一个起点，AI需要利用这些数据来理解词语、句子、语法等基本的语言规则。 Tokenization（分词） 抓取到大量文本后，我们不能直接让模型理解这些文字，因为计算机无法像人类一样“阅读”这些内容。为了让模型理解，我们需要将文本转换为数字，这一过程称为“分词”（Tokenization）。 在分词过程中，每一个单词、符号，甚至空格都会被转换为数字。可以将其理解为为每个词语和符号分配一个唯一的ID，这样计算机就能通过这些数字来处理语言。 在上面的示例中，模型实际上看到的是 59907, 682, 279...，而模型的输出也是数字，再用同样的算法转换为人类可读的文本。 预训练模型 “GPT”指的是 “基于 Transformer 的生成式预训练模型” 。这个名称可以拆解为三个关键点： 1. 生成式（Generative） ：它根据已有的上下文生成文字。 2. 预训练（Pre-trained） ：它需要先在一个庞大的数据集上进行训练，这个过程帮助模型学习语言的规律。 3. Transformer：这是模型的具体结构名称，负责高效处理文本序列并捕捉上下文间的关系。 顾名思义，第一步就是基于之前提到的语料库来对模型进行预训练，这一过程可以让模型获得语料库中丰富的的知识。 训练流程示例：下一个单词预测 这是前文语料库中的一段文字： I tend to specialise in shallow depth of field commercial and editorial images, recently I have been involved in portraiture and fashion as the technical challenges have been interesting to me. Most of my work is conducted on site and is taken &quot;free style&quot;. I prefer to work this way, I &quot;find&quot; the image at the time of the event. I am passionate about the &quot;feel&quot; of an image, I love to produce images that evoke an emotion or question from the viewer. If you have something special and creative you wish to produce or take part in then please make contact. Above all the wordy bits.... I just love taking pictures ... Send me an email if you&#x27;re interested in working with me. 训练的核心思路之一就是让模型学习“下一个词”或“下一个句子”的概率分布。例如，我们从上文中任意截取一段文字： “recently I have been involved in portraiture and fashion as the technical challenges have been interesting to me.” 把“recently... challenges have been”这一部分发送给模型，然后让模型猜测接下来的单词是什么。模型会返回一个概率列表，其中包含所有可能的单词以及它们的概率： 下一个单词 概率 good 3.50% apple 20.10% interesting 10.2% ... 根据上文，可以知道正确答案为 interesting，所以就告诉模型需要把 interesting 的概率调高一些，其他的单词概率调低一些， 下一个单词 概率 good 0.30% apple 0.50% interesting 40.40% ... 通过无数次这样的“下一个词”预测和纠正，模型会逐步学会哪种词汇在上下文里更合适、句子怎么组织才通顺。这样一来，模型就能够在看过足够多的文本之后，学到很多语言规律和事实知识。 现代的模型通常可以根据很长的前文来预测下一个单词，如 claude 3.5 sonnet 的上下文长度为 20 万 token, 也就是说这个模型有能力根据大约 20 万字的前文来预测下一个单词是什么。 当训练完成后，我们就得到一个“基础模型”（Base Model）。 这个时候，模型还只是一个预测器，它获得了语料库中的所有知识。给它一段文本，它会根据知识预测出下一个单词。 一个常见的误解是，模型一次性就能预测出整个句子或段落的答案。实际上，模型是逐词逐步生成答案的。比如，当你问它一个问题，它会根据上下文每次只预测一个词，然后程序把这个词加到句子中，再让模型根据这个句子预测下一个词。 如上面这个模型，我在 Max Tokens 那里限制了最多补全 20 次，程序运行的过程如下： 你是谁 - ？ 你是谁？ - 你 你是谁？你 - 从 你是谁？你从 ... 这就是为什么与 ChatGPT 对话时，它会一个字一个字显示出来。 但是，这个模型还不能进行有效的对话。例如，如果我问它“你是谁”，它不会回答“我是 ChatGPT”，而是会尝试补全“？你从哪里来，你要到哪里去？”因为这个模型还没有“聊天”的概念。 把 Base 模型变成能聊天的 Chat 模型 那么，如何将这个基础模型转变为能够和你正常聊天的“智能助手”呢？这就需要 对话格式 和 人类示例 的帮助。 像 OpenAI 等公司会雇佣大量的人工专家，这些专家编写问题并给出对应的回答示范，进而构建一个人类专家的对话语料库，类似下面这样： 接下来，将这些语料通过特定格式发送给模型进行训练： 由于模型之前从未见过 &lt;|im_start| 和 &lt;|im_end| 这样的标签，在训练过程中，模型学会了在遇到这些标签时，以这种格式进行回答，并模仿人类的对话风格： &lt;|im_start|assistant&lt;|im_sep|我是 ChatGPT&lt;|im_end| 当程序检测到 &lt;|im_end| 时，它知道这一句话已经结束，因此不会继续让模型补全。通过这种少量示例的训练，模型便能学习如何在这种格式下进行对话，最终将基础模型转变为能够进行流畅对话的 Chat 模型。 从这一角度来说，你可以把此时的模型看作“人类专家模拟器”，当你提出一个问题时，模型会基于“互联网语料库”中习得的知识，模仿“人类专家语料库”中习得的风格，来回复你的问题。 上下文（Context） 人类在对话时，会根据当前的谈话内容来理解和回应。比如： 人类: 我养了一只狗 人类: 它今天不太开心 即使第二句没有明确说明是谁不开心，我们也能从上下文理解&quot;它&quot;指的是狗。 大语言模型也是如此。当我们和模型对话时，之前的对话的全部内容会作为&quot;上下文&quot;一起传给模型： &lt;|im_start|user&lt;|im_sep| 我养了一只狗 &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 真好，养狗是很有趣的体验。狗狗是什么品种呢? &lt;|im_end| &lt;|im_start|user&lt;|im_sep| 它今天不太开心 &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 模型能够理解&quot;它&quot;指的是狗，因为在之前的对话中已经提到过狗。这种依赖上下文的理解方式让对话更自然。 然而，上下文也有一定的限制： 1. 长度限制：模型能够记住的上下文长度是有限的（例如，GPT-3.5最多为4k个token）。 2. 时效性：每次对话结束后，上下文会被清空，下次对话需要重新开始。 幻觉 尽管模型通过大量的数据学习了许多知识，但它并不总是能够正确回答问题。有时，当模型遇到它不了解的事情时，它会自信地给出一个看似正确的答案，这种现象被称为“幻觉”。这种情况在早期模型中尤为常见。 当模型遇到它不理解的问题时，尽管模型内部的一些神经元可能意识到自己无法给出正确答案，但由于训练数据的风格通常是“自信地回答”，因此模型会在不知道答案时，仍然自信地编造一个答案。 为了让“幻觉”现象更易理解，以下是一些具体的示例： 幻觉示例 1. 虚构引用和来源 人类: 请给我推荐一些关于人工智能的学术论文。 助手: 推荐您阅读 Johnson 等人2023年发表在 Nature 上的论文《The Future Impact of AI on Human Society》(doi: 10.1038/s41586-023-12345-6)... ​ [实际上这篇论文和DOI号都是模型编造的] 2. 编造不存在的网址 人类: 想了解更多信息去哪里查询? 助手: 您可以访问 www.ai-research-center.org 了解更多详细信息。 ​ [这个网址实际上并不存在] 3. 错误的历史事实 人类: 第一台电子计算机是什么时候发明的? 助手: 第一台电子计算机 MARK-I 是由约翰·冯·诺依曼于1932年在普林斯顿大学发明的。 [这个说法混淆了多个历史事实] 减少大语言模型产生“幻觉”的方法 现在的模型在减少&quot;幻觉&quot;方面已有所改善，其中一个有效方法是： 首先准备一系列问题和对应的标准答案，通过测试找出模型容易产生错误回答或&quot;幻觉&quot;的问题。然后将这些问题的标准答案统一改写为&quot;对不起，我不知道...&quot;等诚实的回应，由此形成新的训练语料库。用这个经过处理的语料库重新训练模型，使其学会在面对不确定的问题时，能够坦诚地承认&quot;我不知道&quot;，而不是随意作答。 搜索 大语言模型虽然学习了大量的知识，但仍然存在两个主要问题： 1. 知识不够新：模型的知识都是截止到训练时的，训练之后发生的事情它就无法知晓了。 2. 可能会胡说：有时候模型会自信满满地给出看似正确的答案，但实际上可能是错误的（即“幻觉”问题）。 为了解决这些问题，我们可以将类似 Google 的搜索工具与模型结合，用搜索引擎返回的知识给模型做参考，帮助模型作答。 注意模型不能直接访问互联网，我们做的只是教会如何它与搜索工具进行交互。具体做法是准备这样的训练数据： 原来的对话是这样的： &lt;|im_start|user&lt;|im_sep| 2024年世界杯冠军是谁？ &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 对不起，我不知道。 &lt;|im_end| 改为如下： &lt;|im_start|user&lt;|im_sep| 2024年世界杯冠军是谁？ &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 这个我得查一下最新的体育赛事信息。 &lt;|search|2024年世界杯冠军队|2024 World Cup winner&lt;|/search| &lt;|im_end| 用这种语料训练后，模型就学会了： 1. 知道何时需要查找最新信息。 2. 主动提出要进行搜索。 3. 正确生成搜索关键词。 实际应用中，流程大致如下： 1. 用户询问：特斯拉最新股价是多少？ 2. 模型发现需要最新的数据，于是返回一个搜索标记，并带上搜索关键词： &lt;|im_start|user&lt;|im_sep| 特斯拉最新股价是多少？ &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 让我查查最新股价。 &lt;|search|Tesla stock price today|特斯拉股票实时价格&lt;|/search| &lt;|im_end| 3. 程序看到这个搜索标记，就会去谷歌搜索这些关键词。 4. 搜索引擎返回如下结果 特斯拉(TSLA)股价为193.57美元（2024年2月8日收盘价） 5. 程序将谷歌搜到的结果放进对话，继续调用模型补全： &lt;|im_start|user&lt;|im_sep| 特斯拉最新股价是多少？ &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 让我查查最新股价。 &lt;|search|Tesla stock price today|特斯拉股票实时价格&lt;|/search| &lt;|im_end| &lt;|im_start|system&lt;|im_sep| 搜索结果：特斯拉(TSLA)股价为193.57美元（2024年2月8日收盘价） &lt;|im_end| 6. 模型看到搜索结果，就能回答： &lt;|im_start|user&lt;|im_sep| 特斯拉最新股价是多少？ &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 让我查查最新股价。 &lt;|search|Tesla stock price today|特斯拉股票实时价格&lt;|/search| &lt;|im_end| &lt;|im_start|system&lt;|im_sep| 搜索结果：特斯拉(TSLA)股价为193.57美元（2024年2月8日收盘价） &lt;|im_end| &lt;|im_start|assistant&lt;|im_sep| 根据最新数据，特斯拉股价是193.57美元（2024年2月8日收盘价）。 &lt;|im_end| 通过这些方式，AI能够更加准确和实时地回答问题。">
                <h2><a href="ai-shi-ru-he-xue-hui-liao-tian-de.html">AI 是如何学会聊天的</a></h2>
                <div class="post-date">2025-02</div>
                <div class="excerpt">本文详细介绍了 AI 聊天模型的学习过程，从获取语料库、文本分词、预训练模型，到如何将基础模型转变为能够对话的 Chat 模型。同时讨论了上下文理解、模型幻觉等关键概念，以及如何通过搜索功能来增强模型的实时性和准确性。

 获取语料库

在训练一个AI模型之前，首先需要准备大量的“语料”——即各种文本数据。这些文本数据来源于互联网上的网页、书籍、文章、社交媒体等。可以将这些数据看作是为AI模型提供...</div>
            </div>
            <div class="post-item" data-title="如何在 EasyExcel 的 Handler 中安全设置单元格样式" data-content="简要说明 本指南演示了如何在 EasyExcel 的自定义 Handler 中安全地修改单元格样式，避免因为滥用或直接修改导致的样式冲突，或者超出 Excel 对样式数量的限制。 1. 简介 在使用 [EasyExcel](https://github.com/alibaba/easyexcel) 生成 Excel 文件时，常常需要在自定义 Handler 中调整单元格样式，比如字体颜色、背景色、对齐方式等。然而，若不注意以下问题，容易踩坑： - 直接修改同一个 CellStyle 对象会影响到所有共享该样式的单元格。 - 过量创建新的 CellStyle（例如在循环中反复 cloneStyleFrom）会导致样式数轻松突破 64,000 的 Excel 上限并抛出异常。 本教程将带你避开这些踩坑点，并展示 最佳实践 来在 EasyExcel 中安全地自定义单元格样式。 2. 先决条件 - 熟悉 EasyExcel 的基本用法（如生成 Excel、编写自定义 Handler 等）。 - 已在项目中引入 EasyExcel 依赖并具备 Java 开发环境。 - 对 [Apache POI](https://poi.apache.org/) 有一定了解，因为 EasyExcel 底层使用 POI 来管理单元格样式。 3. 两个常见的错误用法 3.1 错误用法 1：直接修改现有的 CellStyle 下面的示例中，作者从单元格中直接获取现有的 CellStyle 并设置字体为红色。由于同一个 CellStyle 可能被多个单元格引用，这样的修改会无意中影响到其他单元格。 java class ProblematicFontColorHandler extends AbstractCellWriteHandler { @Override public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData cellDataList, Cell cell, Head head, Integer rowIndex, Boolean isHead) { if (isHead) { return; } // 仅作示例：在第二列设置样式 if (cell.getColumnIndex() &#x3D;&#x3D; 1) { Workbook workbook &#x3D; writeSheetHolder.getSheet().getWorkbook(); // ⚠️ 不正确：复用已有的 CellStyle，可能会影响所有引用它的单元格 CellStyle existingStyle &#x3D; cell.getCellStyle(); Font redFont &#x3D; workbook.createFont(); redFont.setColor(IndexedColors.RED.getIndex()); existingStyle.setFont(redFont); // 其他共享此样式的单元格也会变红 } } } 这样做的问题 - CellStyle 复用：Excel（或 POI）会将同一个 CellStyle 对象用于多个单元格。修改一次就会影响到所有使用该样式的单元格。 3.2 错误用法 2：过度使用 cloneStyleFrom 并为每个单元格都创建新样式 如果每个单元格都通过 cloneStyleFrom 的方式创建一个新样式，样式数量很快就会超过 64,000（Excel 限制），然后抛出异常。 java class ExcessiveStyleHandler extends AbstractCellWriteHandler { @Override public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData cellDataList, Cell cell, Head head, Integer rowIndex, Boolean isHead) { if (isHead) { return; } // ⚠️ 不正确：为每一个单元格都创建新的样式 Workbook workbook &#x3D; writeSheetHolder.getSheet().getWorkbook(); CellStyle newStyle &#x3D; workbook.createCellStyle(); CellStyle originalStyle &#x3D; cell.getCellStyle(); newStyle.cloneStyleFrom(originalStyle); newStyle.setFillForegroundColor(IndexedColors.LIGHT_BLUE.getIndex()); newStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND); cell.setCellStyle(newStyle); // 大规模数据时，这种操作很快会触发超过 64,000 样式的限制 } } 这样做的问题 - 突破样式上限：Excel 一张表格最多允许使用 64,000 个样式。如果为每个单元格都创建一次，就会轻易越过此阈值。 4. 正确的修改单元格样式方式 推荐使用 Apache POI 提供的 CellUtil.setCellStyleProperty(cell, key, value) 或类似 API 来设置样式。该方法会智能复用已有的样式对象，而不是每次都新建一个。同时，它也避免了直接修改共享 CellStyle 带来的风险。 要点： 1. 一般属性：对于大多数单元格样式属性（如对齐、背景色、边框等），直接使用 CellUtil.setCellStyleProperty(cell, key, value) 或 CellUtil.setCellStyleProperties(cell, propertiesMap) 即可完成修改。 2. 字体（Font）特殊处理：字体作为独立对象需要特殊处理。优先使用 Workbook.findFont(...) 查找匹配的现有字体，找不到再用 Workbook.createFont() 创建。然后通过 CellUtil.setFont(cell, font) 应用。尽量复用现有字体，这样可以避免 EasyExcel 内部去重算法失效，并让 POI 更有效地匹配和复用已存在的样式。 5. 完整示例 5.1 ExcelData 类 首先定义数据模型，并使用 EasyExcel 的注解： java @Data class ExcelData { @ExcelProperty(&quot;字符串标题&quot;) private String text; @ExcelProperty(&quot;日期标题&quot;) private Date date; @ExcelProperty(&quot;数字标题&quot;) private Double number; } 5.2 使用正确的 Handler 下面是一个正确的做法，只在第二列修改字体颜色： java class FontColorHandler extends AbstractCellWriteHandler { @Override public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData cellDataList, Cell cell, Head head, Integer rowIndex, Boolean isHead) { if (isHead) { return; } // 仅处理第 2 列（下标为 1） if (cell.getColumnIndex() &#x3D;&#x3D; 1) { Workbook workbook &#x3D; writeSheetHolder.getSheet().getWorkbook(); // 获取当前单元格所使用的字体 Font existingFont &#x3D; workbook.getFontAt(cell.getCellStyle().getFontIndexAsInt()); // 检查是否已存在匹配的红色字体 Font newFont &#x3D; workbook.findFont( existingFont.getBold(), IndexedColors.RED.getIndex(), existingFont.getFontHeight(), existingFont.getFontName(), existingFont.getItalic(), existingFont.getStrikeout(), existingFont.getTypeOffset(), existingFont.getUnderline() ); // 如果没有找到匹配的字体，则创建一个新的 if (newFont &#x3D;&#x3D; null) { newFont &#x3D; workbook.createFont(); newFont.setBold(existingFont.getBold()); newFont.setColor(IndexedColors.RED.getIndex()); newFont.setFontHeight(existingFont.getFontHeight()); newFont.setFontName(existingFont.getFontName()); newFont.setItalic(existingFont.getItalic()); newFont.setStrikeout(existingFont.getStrikeout()); newFont.setTypeOffset(existingFont.getTypeOffset()); newFont.setUnderline(existingFont.getUnderline()); } // 使用 CellUtil 来保证对样式的复用处理 CellUtil.setFont(cell, newFont); // 可选：设置对齐方式 CellUtil.setCellStyleProperty(cell, CellUtil.ALIGNMENT, HorizontalAlignment.CENTER); // 或通过 Map 一次性传入多个属性 Map&lt;String, Object properties &#x3D; new HashMap&lt;(); properties.put(CellUtil.ALIGNMENT, HorizontalAlignment.CENTER); CellUtil.setCellStyleProperties(cell, properties); } } } 5.3 校验代码有效性 下面代码可以打印当前 Excel 中已经创建的 CellStyle 数量，在 Handler 前后打印一下可以用来检验 Handler 中设置的样式是否被复用。 java log.info(workbook.getNumCellStyles()); 如何避免问题 - 不直接调用 cell.getCellStyle().setFont(...) 修改现有样式。 - 尽量重用匹配的字体或样式，减少无谓的新建。 6. 总结 如果想在 EasyExcel 中安全地自定义单元格样式，可以遵循以下要点： 1. 不要直接修改已有 CellStyle，否则可能影响所有共享该样式的单元格。 2. 不要为每个单元格都创建新的样式，否则极易触发 Excel 64,000 样式上限。 3. 合理使用 CellUtil 和 findFont，让 Apache POI 来对已有的样式进行复用。 采用这些方法即可在避免样式冲突的同时，得到所需的单元格格式。 --- 更多阅读 - [EasyExcel GitHub 仓库](https://github.com/alibaba/easyexcel) - [Apache POI CellUtil 源码文档](https://poi.apache.org/apidocs/dev/org/apache/poi/ss/util/CellUtil.html) - [The Good Docs Project](https://thegooddocsproject.dev/) 了解更多文档写作模板和最佳实践。">
                <h2><a href="ru-he-zai-easyexcel-de-handler-zhong-an-quan-she-zhi-dan-yuan-ge-yang-shi.html">如何在 EasyExcel 的 Handler 中安全设置单元格样式</a></h2>
                <div class="post-date">2025-01</div>
                <div class="excerpt">简要说明

本指南演示了如何在 EasyExcel 的自定义 Handler 中安全地修改单元格样式，避免因为滥用或直接修改导致的样式冲突，或者超出 Excel 对样式数量的限制。

 1. 简介

在使用 [EasyExcel](https://github.com/alibaba/easyexcel) 生成 Excel 文件时，常常需要在自定义 Handler 中调整单元格样式，比如字体颜色、...</div>
            </div>
            <div class="post-item" data-title="如何在 IntelliJ IDEA 中使用增强的 HotSwap 功能" data-content="概述 在 Java 开发中，HotSwap 是一项允许开发者在不重启应用程序的情况下更新运行中代码的技术。虽然 IntelliJ IDEA 自带了 HotSwap 功能，但其使用存在诸多限制，难以满足复杂的开发需求。另一方面，JRebel 作为一个强大的热部署工具，虽然功能强大，但其高昂的价格可能不适合所有开发者或团队。 本文将指导您如何在 IntelliJ IDEA 中设置和使用增强的 HotSwap 功能，作为一种折中的解决方案。通过使用 DCEVM 和 HotSwapAgent，您可以克服标准 HotSwap 的限制，实现更灵活的代码热更新，同时避免了高额的许可费用。这种方法提供了一个免费且功能相对强大的替代方案，能够显著提升开发效率。 在接下来的内容中，我们将详细介绍如何配置和使用这些工具，使您能够在日常开发中享受到近似 JRebel 的热部署体验，而无需支付额外费用。这对于需要频繁修改和测试代码的开发者来说，是一个非常有价值的技能。 背景知识 HotSwap HotSwap 是 Java 虚拟机（JVM）的一个特性，允许开发者在调试过程中替换正在运行的代码。它最初在 J2SE 1.4 中引入，旨在提高开发效率。然而，标准的 HotSwap 功能有很多限制，如只能修改方法体等。这些限制源于 JVM 的设计，因为允许任意的运行时代码修改可能会导致严重的内存和性能问题。 DCEVM (Dynamic Code Evolution VM) DCEVM 是 JVM 的一个修改版本，它极大地扩展了 Java HotSwap 的能力。DCEVM 项目始于 2010 年，旨在克服标准 HotSwap 的限制。它允许在运行时进行更广泛的代码更改，包括： - 添加和删除类成员 - 修改方法签名 - 更改类层次结构 - 重新定义枚举常量 DCEVM 通过修改 JVM 的内部实现来实现这些功能，使得更复杂的代码更改成为可能。 HotSwapAgent HotSwapAgent 是一个 Java agent，它与 DCEVM 配合使用，提供额外的类重定义和重加载功能。它的主要特点包括： - 自动检测类文件的变化并重新加载它们 - 支持各种 Java 框架和库的热重载 - 提供插件系统以扩展其功能 HotSwapAgent 通过在类加载时注入额外的字节码来工作，这使得它能够捕获和处理类的变化。 HotSwapHelper HotSwapHelper 是一个为 IntelliJ IDEA 设计的插件，它简化了 DCEVM 和 HotSwapAgent 的使用过程。这个插件的主要功能包括： - 在 IDEA 界面中添加一个快捷按钮来启动增强的 HotSwap 调试 - 自动配置必要的 VM 参数 - 提供简单的用户界面来管理 HotSwap 相关的设置 HotSwapHelper 的目标是使开发者能够轻松地在他们的日常开发工作流程中集成和使用增强的 HotSwap 功能。 前提条件 - 安装了 IntelliJ IDEA - 已安装 JDK 1.8.0_181（本教程以此版本为例，DCEVM 支持特定的 JDK 版本） - 基本了解 Java 开发和调试过程 步骤 1. 了解标准 HotSwap 的限制 标准 HotSwap 有以下限制： - 仅支持修改方法体 - 不支持添加或删除类成员 - 当修改的方法在调用栈中时，更改可能不会立即生效 这些限制大大降低了开发效率，尤其是在处理复杂的代码更改时。 2. 安装 DCEVM 1. 下载 [JDK 1.8.0_181](https://www.oracle.com/hk/java/technologies/javase/javase8-archive-downloads.html)（如果尚未安装） 2. 从 [DCEVM 官网](https://dcevm.github.io/) 下载对应的 Java 8 update 181 版本补丁 3. 运行下载的 DCEVM-8u181-installer.jar 4. 在安装器中选择 &quot;Install DCEVM as altjvm&quot; 安装 DCEVM 不会影响您现有的 JVM 安装，它作为一个替代 JVM 存在。 3. 安装 HotSwapHelper 插件 1. 在 IntelliJ IDEA 中，转到 &lt;ui-pathFile | Settings | Plugins&lt;/ui-path 2. 搜索 &quot;HotSwapHelper&quot; 并安装 这个插件会在 IDEA 的工具栏中添加一个 &quot;HotSwap Debug&quot; 按钮，使得启动增强的 HotSwap 调试变得简单。 4. 配置和使用增强的 HotSwap 1. 在 IntelliJ IDEA 中，创建或打开一个 Java 项目 2. 点击工具栏中新增的 &quot;HotSwap Debug&quot; 按钮启动调试 3. 在控制台中查看日志，确认是否出现 org.hotswap.agent.HotswapAgent 字样 当你看到 HotswapAgent 相关的日志时，说明增强的 HotSwap 功能已经成功启动。 5. 应用代码更改 1. 在调试模式下，修改你的代码 2. 触发重新编译： - 在 IDEA 中，使用快捷键 Ctrl+F9 (Windows/Linux) 或 Cmd+F9 (Mac) 重新编译修改的类 - 或者，在工具栏中点击 &quot;Build Project&quot; 按钮 3. DCEVM 和 HotSwapAgent 会自动检测并应用这些更改 结果 成功配置和应用更改后，您将能够： - 修改方法签名 - 添加或删除类成员 - 在触发重新编译后，即时看到代码更改的效果，即使方法在调用栈中 这些增强大大提高了开发效率，允许您在不重启应用程序的情况下进行更广泛的代码更改。但请注意，虽然 DCEVM 和 HotSwapAgent 大大扩展了热更新的能力，某些复杂的更改（如更改类层次结构）可能仍需要重启应用才能完全生效。 注意事项 - 某些更改可能需要手动触发类的重新加载。在这种情况下，你可能需要重新调用包含更改的方法或重新进入相关的代码路径。 - 虽然 DCEVM 允许在运行时进行广泛的代码更改，但它并不能解决所有的热更新场景。对于非常复杂的更改，重启应用可能仍然是最安全和最可靠的选择。 - 在生产环境中使用热更新技术时要格外小心，因为它可能引入意外的行为或性能问题。 故障排除 - 如果未看到 &quot;HotSwap Debug&quot; 按钮，请确保已正确安装 HotSwapHelper 插件。 - 如果日志中没有 HotswapAgent 相关信息，检查 DCEVM 是否正确安装。 - 如果某些更改没有生效，尝试触发一个完整的类重新加载（可能需要调用包含更改的类的方法）。 相关资源 - [IntelliJ IDEA 官方文档：Altering the Program&#x27;s Execution Flow](https://www.jetbrains.com/help/idea/altering-the-program-s-execution-flow.html) - [IntelliJ 官方指南：How to use Dynamic Code Evolution VM (DCEVM) in IntelliJ Java debugger](https://youtrack.jetbrains.com/articles/SUPPORT-A-725/How-to-use-Dynamic-Code-Evolution-VM-DCEVM-in-IntelliJ-Java-debugger) - [DCEVM 项目页面](https://dcevm.github.io/) - [HotSwapAgent 官网](https://hotswapagent.org/) - [HotSwapHelper GitHub 仓库](https://github.com/gejun123456/HotSwapHelper) 通过使用 DCEVM、HotSwapAgent 和 HotSwapHelper，您可以显著提升 Java 开发的效率，减少因代码更改而导致的应用重启次数。这对于大型项目或有复杂启动过程的应用尤其有益。">
                <h2><a href="ru-he-zai-intellij-idea-zhong-shi-yong-zeng-qiang-de-hotswap-gong-neng.html">如何在 IntelliJ IDEA 中使用增强的 HotSwap 功能</a></h2>
                <div class="post-date">2024-11</div>
                <div class="excerpt">概述

在 Java 开发中，HotSwap 是一项允许开发者在不重启应用程序的情况下更新运行中代码的技术。虽然 IntelliJ IDEA 自带了 HotSwap 功能，但其使用存在诸多限制，难以满足复杂的开发需求。另一方面，JRebel 作为一个强大的热部署工具，虽然功能强大，但其高昂的价格可能不适合所有开发者或团队。

本文将指导您如何在 IntelliJ IDEA 中设置和使用增强的 Ho...</div>
            </div>
            <div class="post-item" data-title="插入操作中的死锁现象" data-content="[InnoDB 中不同 SQL 语句设置的锁](https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html) 在带有唯一索引的表中执行 INSERT 操作时，数据库会在间隙上设置插入意图间隙锁（insert intention gap lock），并对插入的行设置独占锁。然而，这并不会阻止其他事务在相同间隙内插入不同的行。 比如下面这种，间隙为 4 到 7，两个事务分别在这个间隙插入 5 和 6，由于这些行没有冲突，因此不会相互阻塞 text 索引记录: | 4 | 间隙 | 7 | 事务 1 插入: ^5 事务 2 插入: ^6 当三个事务插入同一行时，可能会报错死锁 text 索引记录: | 4 | 间隙 | 7 | 事务 1 插入: ^5 事务 2 插入: ^5 事务 3 插入: ^5 下面探究一下报错死锁的原因 实验步骤 创建报错环境 创建表： sql CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE &#x3D; InnoDB; 会话 1 sql 启动事务 START TRANSACTION; 插入记录 INSERT INTO t1 VALUES(1); 此操作会为值为 1 的行获取一个独占锁。 会话 2 sql 启动事务 START TRANSACTION; 尝试插入相同的记录 INSERT INTO t1 VALUES(1); 由于会话 1 已经持有独占锁，这次插入操作会导致重复键错误，并请求一个共享锁。 会话 3 sql 启动事务 START TRANSACTION; 尝试插入相同的记录 INSERT INTO t1 VALUES(1); 同样，这也会导致重复键错误，并请求一个共享锁。 制造报错并分析结果 此时使用 SHOW ENGINE INNODB STATUS;，会话 1 的部分如下： text ---TRANSACTION 2704, ACTIVE 13 sec 2 lock struct(s), heap size 1128, 1 row lock(s), undo log entries 1 MySQL thread id 47, OS thread handle 140111910045440, query id 4213 10-148-0-7.cilium-agent.kube-system.svc.cluster.local 10.148.0.7 root starting / ApplicationName&#x3D;DataGrip 2024.2.1 / SHOW ENGINE INNODB STATUS 1 row lock(s) : 持有一个行锁。后面的 s 表示可能是复数，不是共享锁的 s，这里看不出是啥锁。 发现会话 2 和会话 3 都显示类似下面的信息 text ---TRANSACTION 2713, ACTIVE 2 sec inserting mysql tables in use 1, locked 1 LOCK WAIT 2 lock struct(s), heap size 1128, 1 row lock(s) MySQL thread id 57, OS thread handle 140111910315776, query id 4202 10-148-0-7.cilium-agent.kube-system.svc.cluster.local 10.148.0.7 root update / ApplicationName&#x3D;DataGrip 2024.2.1 / INSERT INTO t1 VALUES(1) ------- TRX HAS BEEN WAITING 2 SEC FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 3 page no 4 n bits 72 index PRIMARY of table mydb.t1 trx id 2713 lock mode S locks rec but not gap waiting Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0 0: len 4; hex 80000001; asc ;; 1: len 6; hex 000000000a90; asc ;; 2: len 7; hex 81000001110110; asc ;; TRX HAS BEEN WAITING 2 SEC FOR THIS LOCK TO BE GRANTED : 该线程正在等待锁 index PRIMARY of table mydb.t1 trx id 2713 lock mode S : 正在等待获取表mydb.t1的PRIMARY索引上的共享锁（S锁） locks rec but not gap waiting : 锁定记录但不锁定间隙 会话 1 sql 回滚事务 ROLLBACK; 这将释放会话 1 持有的独占锁，允许会话 2 和会话 3 获取共享锁。 观察死锁 在任何一个会话中运行以下命令以查看 InnoDB 状态 sql SHOW ENGINE INNODB STATUS; text ------------------------ LATEST DETECTED DEADLOCK ------------------------ 2024-08-15 02:43:23 140111312307968 (1) TRANSACTION: TRANSACTION 2569, ACTIVE 34 sec inserting mysql tables in use 1, locked 1 LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s) MySQL thread id 44, OS thread handle 140111909775104, query id 2361 10-148-0-7.cilium-agent.kube-system.svc.cluster.local 10.148.0.7 root update / ApplicationName&#x3D;DataGrip 2024.2.1 / INSERT INTO t1 VALUES(1) (1) HOLDS THE LOCK(S): RECORD LOCKS space id 3 page no 4 n bits 72 index PRIMARY of table mydb.t1 trx id 2569 lock mode S Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 0: len 8; hex 73757072656d756d; asc supremum;; (1) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 3 page no 4 n bits 72 index PRIMARY of table mydb.t1 trx id 2569 lock_mode X insert intention waiting Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 0: len 8; hex 73757072656d756d; asc supremum;; (2) TRANSACTION: TRANSACTION 2573, ACTIVE 17 sec inserting mysql tables in use 1, locked 1 LOCK WAIT 4 lock struct(s), heap size 1128, 2 row lock(s) MySQL thread id 57, OS thread handle 140111910315776, query id 2434 10-148-0-7.cilium-agent.kube-system.svc.cluster.local 10.148.0.7 root update / ApplicationName&#x3D;DataGrip 2024.2.1 / INSERT INTO t1 VALUES(1) (2) HOLDS THE LOCK(S): RECORD LOCKS space id 3 page no 4 n bits 72 index PRIMARY of table mydb.t1 trx id 2573 lock mode S Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 0: len 8; hex 73757072656d756d; asc supremum;; (2) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 3 page no 4 n bits 72 index PRIMARY of table mydb.t1 trx id 2573 lock_mode X insert intention waiting Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0 0: len 8; hex 73757072656d756d; asc supremum;; WE ROLL BACK TRANSACTION (2) HOLDS THE LOCK(S) : 会话 1 回滚后，会话 2 和会话 3 都获得了共享锁（S) WAITING FOR THIS LOCK TO BE GRANTED - X insert intention waiting (等待获取插入意图锁) : 可见会话 2 和会话 3 都想把共享锁（S）升级为独占锁（X），导致死锁 WE ROLL BACK TRANSACTION (2) : 其中一个会话被回滚 原因 - 死锁原因： 插入时如果发生重复键错误，则会在重复索引记录上设置共享锁。会话 2 和会话 3 都持有共享锁，但由于需要升级为独占锁才能插入相同的行，所以相互阻塞，导致死锁。 - 死锁检测和处理： InnoDB 通常会自动检测到死锁，并回滚其中一个事务以解决问题。">
                <h2><a href="cha-ru-cao-zuo-zhong-de-si-suo-xian-xiang.html">插入操作中的死锁现象</a></h2>
                <div class="post-date">2024-08</div>
                <div class="excerpt">[InnoDB 中不同 SQL 语句设置的锁](https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html)

在带有唯一索引的表中执行 INSERT 操作时，数据库会在间隙上设置插入意图间隙锁（insert intention gap lock），并对插入的行设置独占锁。然而，这并不会阻止其他事务在相同间隙内插入不同的行。

比如下...</div>
            </div>
            <div class="post-item" data-title="Windows 交换 ESC 和 CapsLock" data-content="交换 将下面代码保存成 .reg 文件 Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout] &quot;Scancode Map&quot;&#x3D;hex:00,00,00,00,00,00,00,00,03,00,00,00,3a,00,01,00,01,00,3a,00,00,00,00,00 运行然后重启 恢复 &lt;procedure title&#x3D;&quot;恢复&quot; type&#x3D;&quot;steps&quot; id&#x3D;&quot;&quot; &lt;stepWin + R&lt;/step &lt;step运行 regedit&lt;/step &lt;step打开 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout&lt;/step &lt;step删除该映射文件，再重启电脑，键盘就可以恢复按键原本的位置了。&lt;/step &lt;/procedure">
                <h2><a href="windows-jiao-huan-esc-he-capslock.html">Windows 交换 ESC 和 CapsLock</a></h2>
                <div class="post-date">2023-11</div>
                <div class="excerpt">交换

将下面代码保存成 .reg 文件


Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
&quot;Scancode Map&quot;&#x3D;hex:00,00,00,00,00,00,00,00,03,00,00,00,3a,00,01,00,01...</div>
            </div>
            <div class="post-item" data-title="Docker 网络相关命令" data-content="- docker network create 创建网络 - docker network connect 将容器连接到网络 - docker network ls 列出所有网络 - docker network rm 删除网络 - docker network disconnect 将容器从网络断开 - docker network inspect 查看网络信息 列出所有网络 bash docker network ls 创建网络 bash docker network create &lt;my-net 查看网络信息 bash docker network inspect &lt;my-net 查看容器的信息 bash docker network inspect &lt;my-docker-name 将一个容器连接到网络 bash docker network connect &lt;my-net &lt;my-docker-name 创建容器时就指定网络，以 busybox 为例 bash docker run -it --rm --name busybox1 --network &lt;my-net busybox sh 给容器在指定网络中起一个别名，网络中的容器可以通过别名访问 bash docker run --net &lt;my-net -itd --name &lt;my-docker-name --net-alias &lt;alias-name busybox 多个容器起一个别名时第一个起的有效，第一个下线后第二个有效 将容器从网络断开 bash docker network disconnect &lt;my-net &lt;my-docker-name 删除创建的网络 bash docker network rm &lt;my-net 需要保证该网络没有容器链接">
                <h2><a href="docker-network.html">Docker 网络相关命令</a></h2>
                <div class="post-date">2023-06</div>
                <div class="excerpt">- docker network create 创建网络
 - docker network connect 将容器连接到网络
 - docker network ls 列出所有网络
 - docker network rm 删除网络
 - docker network disconnect 将容器从网络断开
 - docker network inspect 查看网络信息


列出所有网络

b...</div>
            </div>
            <div class="post-item" data-title="查看 Linux 服务器日志的技巧" data-content="倒叙查看最近的异常 Bash tac logs/example.log | grep -B 100 -A 100 -i exception | more">
                <h2><a href="cha-kan-linux-fu-wu-qi-ri-zhi-de-ji-qiao.html">查看 Linux 服务器日志的技巧</a></h2>
                <div class="post-date">2023-05</div>
                <div class="excerpt">倒叙查看最近的异常

Bash
tac logs/example.log | grep -B 100 -A 100 -i exception | more...</div>
            </div>
            <div class="post-item" data-title="正则表达式" data-content="[正则测试](https://regex101.com/) [正则图](https://regexper.com/) 元字符 | 分类 | 符号 | 含义 | |-------|------|------------| | 特殊单字符 | . | 任意字符（换行除外） | | 特殊单字符 | \d | 任意数字 | | 特殊单字符 | \D | 任意非数字 | | 特殊单字符 | \w | 任意字母数字下划线 | | 特殊单字符 | \W | 任意非字母数字下划线 | | 特殊单字符 | \s | 任意空白符 | | 特殊单字符 | \S | 任意非空白符 | | 分类 | 符号 | 含义 | |-----|------|-------| | 空白符 | \r | 回车符 | | 空白符 | \n | 换行符 | | 空白符 | \f | 换页符 | | 空白符 | \t | 制表符 | | 空白符 | \v | 垂直制表符 | | 空白符 | \s | 任意空白符 | | 分类 | 符号 | 含义 | |----|---------|------------| | 量词 | . | 0 到多次 | | 量词 | + | 1 到多次 | | 量词 | ? | 0 到 1 次 | | 量词 | {m} | 出现 m 次 | | 量词 | {m,} | 出现至少 m 次 | | 量词 | {m,n} | 出现 m 到 n 次 | | 分类 | 符号 | 含义 | |----|----------|-------------------------| | 范围 | \| | 或，如 ab\|bc 代表 ab 或 bc | | 范围 | [...] | 多选1，括号中任意单个元素 | | 范围 | [a-z] | 匹配 a 到 z 之间任意单个元素 | | 范围 | [^...] | 取反，不能是括号中任意单个元素 | 贪婪模式 量词 | 符号 | 同义符号 | 含义 | 示例 | |-----|---------|---------|-----------------------------------| | | {0,} | 0 到多次 | ab 可以匹配 a、ab、abb 等 | | + | {1,} | 1 到多次 | ab+ 可以匹配 ab、abb 等，但不能匹配 a | | ? | {0,1} | 0 到 1 次 | ab? 可以匹配 a、ab，但不能匹配 abb | 贪婪匹配（Greedy） 尽可能进行最长匹配 用法：贪婪匹配为默认模式，如 a 匹配不上会回溯 字符串 aaabb 下标 012345 | 匹配 | 开始 | 结束 | 说明 | 匹配内容 | |-----|----|----|-----------------------|------| | 第1次 | 0 | 3 | 到第一个字母b发现不满足,输出aaa | aaa | | 第2次 | 3 | 3 | 匹配剩下的bb,发现匹配不上,输出空字符串 | 空字符串 | | 第3次 | 4 | 4 | 匹配剩下的b,发现匹配不上,输出空字符串 | 空字符串 | | 第4次 | 5 | 5 | 匹配剩下空字符串,输出空字符串 | 空字符串 | 懒惰匹配（Lazy） 尽可能进行最短匹配 用法：在贪婪匹配后加 ?，如 a? 匹配不上不会回溯 独占匹配（Possessive） 与贪婪模式类似，尽可能进行最长匹配，如果匹配失败就结束， 不会进行回溯，比较节省时间。 用法：“数量”元字符后加 + 。如 a+ | 模式 | 正则 | 文本 | 结果 | |-------|-------------|--------|-----| | 贪婪模式 | a{1,3}ab | aaab | 匹配 | | 非贪婪模式 | a{1,3}?ab | aaab | 匹配 | | 独占模式 | a{1,3}+ab | aaab | 不匹配 | &lt;deflist &lt;def title&#x3D;&quot;回溯（Backtracking）&quot; &lt;p后面匹配不上，会吐出已匹配的再尝试&lt;/p &lt;/def &lt;/deflist 分组与引用 - 将某部分（子表达式）看成一个整体 - 在后续查找或替换中引用分组 分组与编号 括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组。第几个括号就是第几个分组。 非捕获分组 在括号里面的会保存成子组，但有些情况下，你可能只想用括号将某些部分看成一个整体，后续不用再用它。 用法：在括号中使用 ?: | 类型 | 正则 | 示例 | |-------|----------|--------------------| | 保存子组 | (正则) | \d{15}(\d{3})? | | 不保存子组 | (?:正则) | \d{15}(?:\d{3})? | 命名分组 命名分组的格式为 (?P&lt;分组名正则) ^profile/(?P&lt;username\w+)/$ 引用分组 &lt;table &lt;tr &lt;td &lt;/td &lt;td &lt;/td &lt;/tr &lt;/table 匹配模式 匹配模式（Match Mode）：指的是正则中一些改变元字符匹配行为的方式，通过模式修饰符来指定 用法：(?模式标识)正则表达式 可以将多种模式标识放一起 (?标识1标识2)正则表达式 可通过添加括号来改变模式标识作用范围 不区分大小写模式（Case-Insensitive） 用法：正则前添加模式修饰符 (?i) 例： (?i)cat 不区分大小写的 cat，同 [Cc][Aa][Tt] 匹配两个 cat 时： | 正则 | 效果 | |------------------|---------------------------------| | (?i)(cat) \1 | 可以匹配前后大小写不同，即 (?i) 范围包扩 \i | | ((?i)cat) \1 | 前后大小写必须相同，限制了 (?i) 的范围 | | ((?i)(cat)) \1 | 会多出一个子组，和 ((?i)(cat)) \2 效果一样 | 点号通配模式（Dot All） 也叫单行匹配模式（Single Line） 用法：正则前添加模式修饰符 (?s) 通常 . 不能匹配换行符，使用点号通配模式可以匹配上换行符 也可以使用 [\s\S] 或 [\d\D] 或 [\w\W] 等实现匹配真正任意字符 多行匹配模式（Multiline） 用法：正则前添加模式修饰符 (?m) 通常 ^ 匹配整个字符串的开头， $ 匹配整个字符串的结尾 多行匹配模式下会匹配每行的开头或结尾 正则中还有\A 仅匹配整个字符串的开始，\z 仅匹配整个字符串的结束，在多行匹配模式下，它们的匹配行为不会改变，如果只想匹配整个字符串，而不是匹配每一行，用这个更严谨一些。 注释模式（Comment） 正则中书写注释 用法 (?comment) 例： (\w+) \1 添加注释后 (\w+)(?word) \1(?word repeat again) 断言 单词边界（Word Boundary） 用法：正则中使用\b 来表示单词的边界 | | tom 单词包含 tom | \btom 以 tom 开头的单词 | tom\b 以 tom 结尾的单词 | \btom\b 只能是 tom | |------------|----------------|---------------------|---------------------|-------------------| | tom | ✅ | ✅ | ✅ | ✅ | | tomorrow | ✅ | ✅ | 🚫 | 🚫 | | atom | ✅ | 🚫 | ✅ | 🚫 | | atomic | ✅ | 🚫 | 🚫 | 🚫 | \b\w+\b 匹配单词，或者空格分隔的字符串等 行的开始或结束 用法：使用 ^和 $匹配行的开始或结束（多行匹配模式） \A和 \z匹配整个字符串的开始或结束，不受匹配模式的影响。 例如：^\d{6}$匹配六位数字 各平台换行符： | 平台 | 换行符号 | |---------|--------| | Windows | \r\n | | Linux | \n | | macOS | \n | 环视（ Look Around） 也称零宽断言 用法： | 正则 | 名称 | 含义 | 示例 | |---------|---------------------|----------------|--------------------------------------------| | (?&lt;&#x3D;Y) | 肯定逆序环视 (Positive Lookbehind) | 左边是Y | (?&lt;&#x3D;\d)th 左边是数字的th, 能匹配 9th | | (?&lt;!Y) | 否定逆序环视 (Negative Lookbehind) | 左边不是Y | (?&lt;!\d)th 左边不是数字的th, 能匹配 health | | (?&#x3D;Y) | 肯定顺序环视 (Positive Lookahead) | 右边是Y | six(?&#x3D;\d) 右边是数字的six, 能匹配 six6 | | (?!Y) | 否定顺序环视 (Negative Lookahead) | 右边不是Y | hi(?!\d) 右边不是数字的hi, 能匹配 high | 口诀： - 左尖括号代表看左边 - 没有尖括号是看右边 - 感叹号是非的意思 表示环视的括号不算做子组 例子： 匹配邮政编码 (?&lt;!\d)[1-9]\d{5}(?!\d) 匹配单词 (?&lt;!\w)\w+(?!\w)(?&lt;&#x3D;\W)\w+(?&#x3D;\W)\b\w+\b JavaScript 不支持逆向环视(逆向断言)">
                <h2><a href="zheng-ze-biao-da-shi.html">正则表达式</a></h2>
                <div class="post-date">2022-12</div>
                <div class="excerpt">[正则测试](https://regex101.com/)
[正则图](https://regexper.com/)

 元字符

| 分类    | 符号   | 含义         |
|-------|------|------------|
| 特殊单字符 | .  | 任意字符（换行除外） |
| 特殊单字符 | \d | 任意数字       |
| 特殊单字符 | \D | 任意非...</div>
            </div>
            <div class="post-item" data-title="使用 Git worktree 将同一个项目分裂成多个本地目录" data-content="想要在同一个项目中同时使用多个分支，但是又不想频繁切换分支，可以使用 Git worktree 将同一个项目分裂成多个本地目录。 创建一个新的工作树 bash git worktree add ../new-dir some-existing-branch git worktree add [path] [branch] 删除一个工作树 bash git worktree remove ../new-dir 或者： bash rm -rf ../new-dir git worktree prune">
                <h2><a href="shi-yong-git-worktree-jiang-tong-yi-ge-xiang-mu-fen-lie-cheng-duo-ge-ben-di-mu-lu.html">使用 Git worktree 将同一个项目分裂成多个本地目录</a></h2>
                <div class="post-date">2022-12</div>
                <div class="excerpt">想要在同一个项目中同时使用多个分支，但是又不想频繁切换分支，可以使用 Git worktree 将同一个项目分裂成多个本地目录。

 创建一个新的工作树

bash
git worktree add ../new-dir some-existing-branch
git worktree add [path] [branch] 


 删除一个工作树

bash
git worktree remo...</div>
            </div>
            <div class="post-item" data-title="MySql 死锁时的一种解决办法" data-content="查看数据库的线程情况 sql show processlist; | Id | User | Host | db | Command | Time | State | Info | |----------|--------------|--------------------|-------------|---------|------|-------|------| | 9930577 | business_web | 192.168.1.21:45503 | business_db | Sleep | 153 | | NULL | | 9945825 | business_web | 192.168.1.25:49518 | business_db | Sleep | 43 | | NULL | | 9946322 | business_web | 192.168.1.23:44721 | business_db | Sleep | 153 | | NULL | | 9960167 | business_web | 192.168.3.28:2409 | business_db | Sleep | 93 | | NULL | | 9964484 | business_web | 192.168.1.21:24280 | business_db | Sleep | 7 | | NULL | | 9972499 | business_web | 192.168.3.28:35752 | business_db | Sleep | 13 | | NULL | | 10000117 | business_web | 192.168.3.28:9149 | business_db | Sleep | 6 | | NULL | | 10002523 | business_web | 192.168.3.29:42872 | business_db | Sleep | 6 | | NULL | | 10007545 | business_web | 192.168.1.21:51379 | business_db | Sleep | 155 | | NULL | 查看 State 字段有没有 wait 状态的线程，如果没有看到正在执行的慢SQL记录线程，再去查看innodb的事务表INNODB_TRX，看下里面是否有正在锁定的事务线程，看看ID是否在show full processlist里面的sleep线程中，如果是，就证明这个sleep的线程事务一直没有commit或者rollback而是卡住了，我们需要手动kill掉。 sql SELECT FROM information_schema.INNODB_TRX; Bash 1. row trx_id: 20866 trx_state: LOCK WAIT trx_started: 2014-07-31 10:42:35 trx_requested_lock_id: 20866:617:3:3 trx_wait_started: 2014-07-30 10:42:35 trx_weight: 2 trx_mysql_thread_id: 9930577 trx_query: delete from dltask where id&#x3D;1 trx_operation_state: starting index read trx_tables_in_use: 1 trx_tables_locked: 1 trx_lock_structs: 2 trx_lock_memory_bytes: 376 trx_rows_locked: 1 trx_rows_modified: 0 trx_concurrency_tickets: 0 trx_isolation_level: READ COMMITTED trx_unique_checks: 1 trx_foreign_key_checks: 1 trx_last_foreign_key_error: NULL trx_adaptive_hash_latched: 0 trx_adaptive_hash_timeout: 10000 trx_is_read_only: 0 trx_autocommit_non_locking: 0 终止上面的线程 sql kill 9930577; [MySql 死锁时的一种解决办法](https://www.cnblogs.com/farb/p/MySqlDeadLockOneOfSolutions.html)">
                <h2><a href="mysql-si-suo-shi-de-yi-zhong-jie-jue-ban-fa.html">MySql 死锁时的一种解决办法</a></h2>
                <div class="post-date">2022-12</div>
                <div class="excerpt">查看数据库的线程情况

sql
show processlist;


| Id       | User         | Host               | db          | Command | Time | State | Info |
|----------|--------------|--------------------|-------------|-------...</div>
            </div>
            <div class="post-item" data-title="Redis 批量删除 Key" data-content="普通删除 bash DEL key1 key2 key3 管道 可用keys &quot;str&quot; 列出要删除的key，接linux管道删除 实例： 根据通配符查看待删除的key bash redis-cli KEYS &quot;_MALL_GOODS_KEY” 接linux管道删除之 bash redis-cli KEYS &quot;_MALL_GOODS_KEY&quot;|xargs redis-cli DEL lua 删除 keys 命令在数据量很大的情况下，直接在 redis cli 中执行会严重影响服务器性能，更好的方式是在 lua 脚本中执行 eval 命令可以执行执行 lua 脚本 lua方式通配符查找 bash eval &quot;return redis.call(&#x27;keys&#x27;,KEYS[1])&quot; 1 _MALL_GOODS_KEY bash eval &quot;return redis.call(&#x27;keys&#x27;,KEYS[1])&quot; 1 lua 方式通配符删除 bash eval &quot;return redis.call(&#x27;del&#x27;,unpack(redis.call(&#x27;keys&#x27;,ARGV[1])))&quot; 0 _MALL_GOODS_KEY">
                <h2><a href="redis-pi-liang-shan-chu-key.html">Redis 批量删除 Key</a></h2>
                <div class="post-date">2022-10</div>
                <div class="excerpt">普通删除

bash
DEL key1 key2 key3


 管道

可用keys &quot;str&quot; 列出要删除的key，接linux管道删除

实例：

根据通配符查看待删除的key

bash
redis-cli KEYS &quot;_MALL_GOODS_KEY”


接linux管道删除之

bash
redis-cli KEYS &quot;_MALL_GOODS_KEY&quot;|xargs redis-cli ...</div>
            </div>
            <div class="post-item" data-title="Spring Boot 打印事务日志" data-content="找到事务管理器 Spring 的事务管理器一般继承自 java org.springframework.transaction.PlatformTransactionManager 通过自动注入找到事务管理器 Java @Resource private PlatformTransactionManager ptm; 打印日志或者 debug 即可找道对应的事务管理器 Java log.info(&quot;tm:{}&quot;, ptm); 配置日志级别 根据事务管理器在配置文件中添加配置 yaml logging: level: org: springframework: jdbc: datasource: DataSourceTransactionManager: DEBUG 之后在日志中会打印事务信息">
                <h2><a href="spring-boot-da-yin-shi-wu-ri-zhi.html">Spring Boot 打印事务日志</a></h2>
                <div class="post-date">2022-08</div>
                <div class="excerpt">找到事务管理器

Spring 的事务管理器一般继承自

java
org.springframework.transaction.PlatformTransactionManager


通过自动注入找到事务管理器

Java
@Resource
private PlatformTransactionManager ptm;


打印日志或者 debug 即可找道对应的事务管理器

Java
l...</div>
            </div>
            <div class="post-item" data-title="解决 Windows 中文件正在使用的问题" data-content="当我们试图修改或删除某个文件时，可能收到一个“文件正在使用”的提示。 通过资源监视器找到使用者 &lt;procedure title&#x3D;&quot;打开资源监视器&quot; type&#x3D;&quot;choices&quot; id&#x3D;&quot;open-resource-manager&quot; &lt;step使用快捷键 &lt;shortcutWin+R&lt;/shortcut 打开&quot;运行&quot;对话框，输入 resmon.exe，按回车键运行。&lt;/step &lt;step点击开始菜单，前往&lt;ui-path 所有程序 | Windows 管理工具 | 资源监视器&lt;/ui-path。&lt;/step &lt;/procedure &lt;procedure title&#x3D;&quot;使用资源监视器关闭目标程序&quot; type&#x3D;&quot;steps&quot; id&#x3D;&quot;procedure-id&quot; &lt;step选择 &quot;CPU&quot; 标签&lt;/step &lt;step在“关联的句柄”搜索框中输入您想要释放的文件名&lt;/step &lt;step右键点击相应的进程，选择 &quot;结束进程&quot;&lt;/step &lt;/procedure">
                <h2><a href="jie-jue-windows-zhong-quot-wen-jian-zheng-zai-shi-yong-quot-wen-ti.html">解决 Windows 中文件正在使用的问题</a></h2>
                <div class="post-date">2022-06</div>
                <div class="excerpt">当我们试图修改或删除某个文件时，可能收到一个“文件正在使用”的提示。

 通过资源监视器找到使用者

&lt;procedure title&#x3D;&quot;打开资源监视器&quot; type&#x3D;&quot;choices&quot; id&#x3D;&quot;open-resource-manager&quot;
   &lt;step使用快捷键 &lt;shortcutWin+R&lt;/shortcut 打开&quot;运行&quot;对话框，输入 resmon.exe，按回车键运行。&lt;/step
   ...</div>
            </div>
            <div class="post-item" data-title="Spring 事务传播特性" data-content="背景 问题 在项目中写出了如下模式的代码 java @Override @Transactional public void parent() { // 期望：parent() 不回滚 balabalaService.child(); } @Override public void child() { try { balabalaService.grandChild(); } catch (Exception ignore) { // 忽略异常 } } @Override @Transactional public void grandChild() { // 通过抛出异常回滚当前事务 throw new RuntimeException(&quot;grandChild&quot;); } 上面的代码在 parent() 方法中通过 child() 调用了 grandChild() ，期望 grandChild() 回滚时 parent() 不会回滚。 这段代码实际上是不会按照预期工作的，parent() 方法也会跟着回滚。 解释 当 grandChild() 抛出异常时，会将当前事务标记为回滚，虽然 child() 中捕获了异常，看似 parent() 不会因为异常而回滚，但由于事务的传播特性，现在 grandChild() 与 parent() 处于一个事务中，因此实际上是 parent() 的事务被 grandChild() 标记为了回滚，导致 parent() 发生回滚。 解决 NESTED 既然 parent() 和 grandChild() 两个方法处在一个事务中，我就想能不能在 child() 方法上新建一个嵌套事务，这样 grandChild() 便与 child() 处于同一个事物，因此 grandChild() 回滚时就不会导致 parent() 回滚。 java @Override @Transactional public void parent() { // 期望：parent() 不回滚 balabalaService.child(); } @Override // 开启嵌套事务 @Transactional(propagation &#x3D; Propagation.NESTED) public void child() { try { balabalaService.grandChild(); } catch (Exception ignore) { // 忽略异常 } } @Override @Transactional public void grandChild() { // 通过抛出异常回滚当前事务 throw new RuntimeException(&quot;grandChild&quot;); } 这段代码看起来没啥问题，grandChild() 与 child() 处于同一个嵌套事务中，嵌套事务的回滚不会影响外层事务的回滚，同时又在 child() 捕获了所有的异常，因此外部事物也不会因为接收到异常而回滚，然而事实也不是这样的。 grandChild() 方法的事务传播特性为默认值 REQUIRED ，他的特性之一是「支持当前事务」，那么当前事务是什么呢？ 通过[[Spring Boot 打印事务日志]]等方式发现当前事务是 parent() 方法的事务，也就是说 Propagation.NESTED 方式创建的事务不是真正的事务，实际上他只是 MySQL 中的一个「savepoint」，导致 grandChild() 仍然与 child() 处在同一个事物中。 The SAVEPOINT in MySQL is used for dividing (or) breaking a transaction into multiple units so that the user has a chance of roll backing the transaction up to a specified point. That means using Save Point we can roll back a part of a transaction instead of the entire transaction. 可见：NESTED 中调用带事务的方法可能导致外层事务回滚 REQUIRES_NEW 解决办法就是使用 Propagation.REQUIRES_NEW 创建一个真正的事务。 java @Override @Transactional public void parent() { // 期望：parent() 不回滚 balabalaService.child(); } @Override // 开启嵌套事务 @Transactional(propagation &#x3D; Propagation.Propagation.REQUIRES_NEW) public void child() { try { balabalaService.grandChild(); } catch (Exception ignore) { // 忽略异常 } } @Override @Transactional public void grandChild() { // 通过抛出异常回滚当前事务 throw new RuntimeException(&quot;grandChild&quot;); } 这种情况下，Spring 会暂停当前的事务链接，使用一个新的链接启动一个新的事务，也就是说 REQUIRES_NEW 的事务跟普通的事务是完全一样的。 Catch Exception 此时再运行代码，会发现 child() 方法抛出了一个异常，描述为「Transaction rolled back because it has been marked as rollback-only」，很明显我们已经在 child() 中捕获了所有的异常，那这个异常就不是我们抛出的。由此得知，当事务被标记为 rollback-only 的时候，Spring 会在事务的方法上抛出一个异常。 java @Override @Transactional public void parent() { // 期望：parent() 不回滚 try { balabalaService.child(); } catch (Exception e) { e.printStackTrace(); } } @Override // 开启嵌套事务 @Transactional(propagation &#x3D; Propagation.Propagation.REQUIRES_NEW) public void child() { try { balabalaService.grandChild(); } catch (Exception ignore) { // 忽略异常 } } @Override @Transactional public void grandChild() { // 通过抛出异常回滚当前事务 throw new RuntimeException(&quot;grandChild&quot;); } 在 parent() 方法中捕获异常后，这段代码终于工作了。">
                <h2><a href="spring-shi-wu-chuan-bo-te-xing.html">Spring 事务传播特性</a></h2>
                <div class="post-date">2022-06</div>
                <div class="excerpt">背景

 问题
在项目中写出了如下模式的代码

java
@Override  
@Transactional  
public void parent() {
    // 期望：parent() 不回滚
    balabalaService.child();  
}  
  
@Override    
public void child() {  
    try {  
        ...</div>
            </div>
            <div class="post-item" data-title="锁库大师" data-content="背景 希望在顾客下单时对库存明细表中的商品进行库存锁定，库存明细表简化后如下所示： 可见一条产品编码有可能存在多条库存明细，客户的订单大致会锁定几十行的库存，要求如下： - 尽可能快，并发也高，支持多节点 - 为了数据的一致性，最好不用 redis 扣减的方案 - 锁库同时在锁库流水表中插入锁库记录 优化方案 分析 通过分析系统现有的方案，发现锁库操作时间主要浪费在更新库存明细的锁库数量上，为了防止超卖，每一条更新必须加上库存校验（如下所示），一旦失败就要回滚，在加之 MySQL 并没有提供原生批量更新方法，只能每行库存执行一条 SQL，导致锁库时间较长。 SQL WHERE (stock_quantity - locking_quantity) 0 提高锁库速度 优化的第一步就是想要提高批量锁库的速度，有没有方法能够在 MySQL 中模拟批量更新呢？ WHEN 语句 答案就是使用 SQL 的 when 语句，在程序中拼接出如下的 SQL SQL UPDATE p_stock_instance a SET a.locking_quantity &#x3D; CASE a.id WHEN &#x27;027dbba9c04a4ef0baab3983c64bc0b31123&#x27; THEN 3 WHEN &#x27;025d4574cd934b69993703e7e99e8ca43&#x27; THEN 6 WHEN &#x27;027dbba9c04a4ef0baab3983c64bc0b313&#x27; THEN 2 END, a.update_date &#x3D; now() WHERE CASE a.id WHEN &#x27;027dbba9c04a4ef0baab3983c64bc0b31123&#x27; THEN (a.stock_quantity - a.locking_quantity) &#x3D; 3 WHEN &#x27;025d4574cd934b69993703e7e99e8ca43&#x27; THEN (a.stock_quantity - a.locking_quantity) &#x3D; 6 WHEN &#x27;027dbba9c04a4ef0baab3983c64bc0b313&#x27; THEN (a.stock_quantity - a.locking_quantity) &#x3D; 2 ELSE 0 END; SQL 执行完毕后会返回更新行数，在程序中判断更新行数是否与预期相符即可判断是否更新成功，程序示意如下： java Integer num &#x3D; pStockInstanceDao.operationStockSmallData(operationMapping); if (num !&#x3D; operationMapping.size()) { throw new RuntimeException(&quot;操作失败&quot;); } 这种方法的更新速度很快，在我的测试中，更新两万行库存记录的耗时大约 17 秒。但其实还有更快的方法。 临时表 使用临时表更新库存的方法在数据量比较大的情况下比 WHEN 语句的性能好很多，测试条件下更新两万行库存记录耗时大约 1 秒 临时表是 MySQL 中的一种特殊表，他有如下几个特征： - 临时表是线程内可见，线程之间看不到其他线程创建的临时表 - 线程推出后临时表就被销毁 - 临时表与普通表重名时 MySQL 优先选择临时表操作 本案例中创建临时表的语句如下： SQL create temporary table temp_stock_operation ( stock_instance_id varchar(64) unique not null comment &#x27;库存实例ID&#x27;, op_num int not null comment &#x27;操作数量&#x27;, success tinyint(1) default 0 not null comment &#x27;是否成功&#x27; ); stock_instance_id 就是库存明细表中的 id 更新库存时： 1. 创建临时表 2. 先将每一行库存明细要锁定的库存数量插入到临时表中 3. 然后通过 UPDATE JOIN 语句批量更新库存，同时将是否更新成功的信息保存在临时表的 success 字段中 4. 统计 success 字段，判断是否回滚 5. 删除临时表 使用的 UPDATE 语句如下： SQL update temp_stock_operation o inner join p_stock_instance s on o.stock_instance_id &#x3D; s.id set o.success &#x3D; 1, s.locking_quantity &#x3D; s.locking_quantity + o.op_num where s.stock_quantity - s.locking_quantity &#x3D; o.op_num and o.success &#x3D; 0; 检查是否成功，该语句返回值为 0 或 1 。 SQL select count() &#x3D; 0 as success from temp_stock_operation where success &#x3D; 0; 最后删除临时表： SQL drop temporary table temp_stock_operation; 将二者结合 虽然使用临时表的方案更新大量数据时很快，但是如果使用这个方法来更新几十条库存时就会发现速度又变慢了，在我的测试中，更新三四十条的耗时几乎与更新两万条相等。 就是说这条更新语句在数量少的时候性能会下降 SQL update temp_stock_operation o inner join p_stock_instance s on o.stock_instance_id &#x3D; s.id set o.success &#x3D; 1, s.locking_quantity &#x3D; s.locking_quantity + o.op_num where s.stock_quantity - s.locking_quantity &#x3D; o.op_num and o.success &#x3D; 0; 分析它的执行计划，发现当更新行数小于 45 时，JOIN 操作便不会走索引，而是全表扫描，导致性能下降。这时候即使使用下面的 SQL 语句强制索引也是没用的。 SQL update temp_stock_operation o force index for join (stock_instance_id) inner join p_stock_instance s on o.stock_instance_id &#x3D; s.id set o.success &#x3D; 1, s.locking_quantity &#x3D; s.locking_quantity + o.op_num where s.stock_quantity - s.locking_quantity &#x3D; o.op_num and o.success &#x3D; 0; 所以我们要将这两种方法结合，来获得最佳的性能 java if (operationMapping.size() &lt; 45) { // WHEN 语句方案 Integer num &#x3D; pStockInstanceDao.operationStockSmallData(operationMapping); if (num !&#x3D; operationMapping.size()) { throw new RuntimeException(&quot;操作失败&quot;); } } else { // 临时表方案 Boolean success &#x3D; pStockInstanceDao.operationStockBigData(operationMapping); if (!success) { throw new RuntimeException(&quot;操作失败&quot;); } } 提高并发量 由于并发时多个线程间存在竞态条件，可能导致库存扣减失败，而前面说到库存明细表中一件商品可能对应多条库存明细，就是说如果并发导致有一条库存明细扣减失败的话很可能这个商品在其他的库存明细中还有库存。而且由于无论更没更新成功，线程都会占有数据库行的写锁，这就要求我们更新失败时最好能够快速释放锁，这又会导致接口会误报库存不足。 商品编码锁 一个解决办法如下 1. 线程在执行库存数量查询前为订单中的每个商品编码获取一个分布式锁，只有获得全部商品编码的锁时才进行库存的查询操作 2. 线程在更新完库存后释放所持有的商品编码锁 java RLock[] locks &#x3D; productSids.seream() .distinct() .map(key - &quot;ced:pStockInstance:&quot; + key) .sorted() .map(key - redissonClient.getLock(key)) .toArray(RLock[]::new); RLock skuLock &#x3D; redissonClient.getMultiLock(locks); // 加锁 skuLock.lock(); // 解锁 skuLock.unlockAsync(); 这种方法当所有的订单都锁定同一个商品时就会导致程序退化成串行执行，效率很慢。 和并请求 由于前文我们已经将库存更新的方法优化的足够快，因此想高效地解决竞态条件的问题，可以将各个请求的参数在应用程序中合并在一起，然后使用一个线程批量扣减，从而避免线程间扣减冲突。 使线程阻塞并被唤醒的关键代码如下 java public class GuardedObject&lt;T, K { //受保护的对象 T obj; final Lock lock &#x3D; new ReentrantLock(); final Condition done &#x3D; lock.newCondition(); final int timeout &#x3D; 60; //保存所有GuardedObject final static Map&lt;Object, GuardedObject gos &#x3D; new ConcurrentHashMap&lt;(); public GuardedObject(K key) { this.key &#x3D; key; } K key; // 1. 被请求线程通过唯一 key 获得阻塞对象，然后将 key 存入消息，发送到扣减中心 public static &lt;K GuardedObject create(K key) { GuardedObject go &#x3D; new GuardedObject(key.toString()); gos.put(key, go); return go; } // 2. 被请求线程稍后调用阻塞对象的该方法，阻塞，等待被唤醒 public Optional&lt;T get(Predicate&lt;T p) { lock.lock(); Long start &#x3D; System.currentTimeMillis(); try { while (!p.test(obj)) { done.await(timeout, TimeUnit.SECONDS); if (System.currentTimeMillis() - start &#x3D; timeout 1000) { gos.remove(key); break; } } return Optional.ofNullable(obj); } catch (InterruptedException e) { throw new RuntimeException(e); } finally { lock.unlock(); } } // 3. 结果监听器根据结果消息中的 key 找到对应阻塞对象，传入结果并唤醒对应线程 public static &lt;K, T void fireEvent(K key, T obj) { GuardedObject go &#x3D; gos.remove(key); if (go !&#x3D; null) { go.onChanged(obj); } } //事件通知方法 void onChanged(T obj) { lock.lock(); try { this.obj &#x3D; obj; done.signalAll(); } finally { lock.unlock(); } } } 性能测试 实验环境为了获得最坏情况下的性能，在库存明细中存入了两万五千条同一商品，并将每一条的数据的库存数量设置为 1 在我的电脑中启动两个服务接收请求，启动若干线程对该商品进行扣减，结果如下 | 请求线程数量 | 总计锁库行数 | 全部处理耗时 | | -------- | ------------ | -------- | | 100 | 1000 | 1 S | | 500 | 5000 | 3 S | | 1000 | 10000 | 4 S | | 2000 | 20000 | 8 S | | 3000 | 25000 | 12 S | 注意事项 以下是我在编写代码时发现的一些需要注意的点： 唯一索引 在创建临时表时 stock_instance_id 要创建唯一索引，因为这个字段要充当 JOIN 语句的条件，实测不加唯一索引性能会很差。 SQL create temporary table temp_stock_operation ( stock_instance_id varchar(64) unique not null comment &#x27;库存实例ID&#x27;, 加快消息队列读取 扣减中心的库存扣减线程直接从消息队列读取消息效率较低，在本案例中，可以新建一个本地队列，用其他线程将消息队列中的消息搬运到本地队列，让扣减线程操作本地队列而不是消息队列，这样可以大幅提高扣减效率。 --- 源码请见：https://github.com/solidSpoon/inventory-lock-master">
                <h2><a href="suo-ku-da-shi.html">锁库大师</a></h2>
                <div class="post-date">2022-05</div>
                <div class="excerpt">背景
希望在顾客下单时对库存明细表中的商品进行库存锁定，库存明细表简化后如下所示：



可见一条产品编码有可能存在多条库存明细，客户的订单大致会锁定几十行的库存，要求如下：

- 尽可能快，并发也高，支持多节点
- 为了数据的一致性，最好不用 redis 扣减的方案
- 锁库同时在锁库流水表中插入锁库记录

 优化方案
 分析

通过分析系统现有的方案，发现锁库操作时间主要浪费在更新库存明细的锁...</div>
            </div>
            <div class="post-item" data-title="MongoDB 初探" data-content="MongoDB 初探 对于已经熟悉 MySQL 的同学来说，初次接触 MongoDB 可能会不习惯它的语法，本篇文章将通过一个简单的示例带你入门 MongoDB。 准备 对于 MongoDB 新手，可以借助 DataGrip 来学习MongoDB 语法。在 MongoDB 中实现准备好两个表 &quot;old&quot; 和 &quot;new&quot;，并随意插入一些数据 js db.createCollection(&quot;new&quot;) db.createCollection(&quot;old&quot;) db.old.insertOne({ id: 1, name: old }) db.new.insertOne({ id: 2, name: 13, goods: 1 }) // 随意插入数据 在 DataGrip 中输入如下的 SQL 语句 sql select from &quot;new&quot; as aleft left join &quot;old&quot; as bright on aleft.id &#x3D; bright.id; 然后在这条语句上「右键」，选择 「Show JS Script」，会发现 DataGrip 会帮助我们将 SQL 语句转为 MongoDB 语句，接下来我们通过研究这个语句来体会 MongoDB 的基本思想 js db.getSiblingDB(&quot;test&quot;).getCollection(&quot;new&quot;).aggregate([ { $project: {&quot;aleft&quot;: &quot;$$ROOT&quot;, &quot;_id&quot;: 0} }, { $lookup: { localField: &quot;aleft.id&quot;, from: &quot;old&quot;, foreignField: &quot;id&quot;, as: &quot;bright&quot; } }, { $unwind: { path: &quot;$bright&quot;, preserveNullAndEmptyArrays: true } }, { $replaceRoot: { newRoot: {$mergeObjects: [&quot;$aleft&quot;, &quot;$bright&quot;, &quot;$$ROOT&quot;]} } }, { $project: {&quot;aleft&quot;: 0, &quot;bright&quot;: 0} } ]) 分析 aggregate db.collection.aggregate(管道，选项) 方法参数接收一个包含了若干操作的数组，类似于 Linux 中的管道一样，对集合依次进行操作。 project 第一个操作为 $project ，这是一个映射操作 json { $project: {&quot;aleft&quot;: &quot;$$ROOT&quot;, &quot;_id&quot;: 0} } 其中 $$ROOT 即引用顶级文档，效果是将当前文档（行）的所有数据放到 aleft 字段下。&quot;_id&quot;: 0 代表隐藏 _id 行，当设定为 &quot;_id&quot;: 1 时会展示 _id 行，（_id 由 MongoDB 自动生成）结果示意如下： json [ { &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 } }, { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce445b67f62529d94a83e&quot;}, // 当 _id: 1 时会展示 id &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce445b67f62529d94a83e&quot;}, &quot;id&quot;: 2, &quot;name&quot;: 13, &quot;goods&quot;: 1 } } ] lookup 第二个操作为 json { $lookup: { localField: &quot;aleft.id&quot;, from: &quot;old&quot;, foreignField: &quot;id&quot;, as: &quot;bright&quot; } } 顾名思义，这是一个查找操作，它根据第一步结果中的 aleft.id 字段，在 old 表中查找 id 与之相等的文档（行），并将所有匹配的结果以数组方式放在 bright 字段下，结果示意如下： json [ { &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: [ { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce82ab67f62529d94a84c&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; }, { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce867b67f62529d94a84e&quot;}, &quot;id&quot;: 1, &quot;vbsss&quot;: &quot;haha&quot; } ] } ] unwind 第三个操作为 json { $unwind: { path: &quot;$bright&quot;, preserveNullAndEmptyArrays: true } } 这个操作指明了使用 $bright 字段，这个字段是一个数组，$unwind 操作会将 $bright 中的每一个元素与 aleft 组合 json [ { &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce82ab67f62529d94a84c&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; } }, { &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce867b67f62529d94a84e&quot;}, &quot;id&quot;: 1, &quot;vbsss&quot;: &quot;haha&quot; } } ] 至此，我们已经将两个表中关联的行组合在了一起，接下来需要将这个结构简化一下 replaceRoot 第四个操作为 json { $replaceRoot: { newRoot: {$mergeObjects: [&quot;$aleft&quot;, &quot;$bright&quot;, &quot;$$ROOT&quot;]} } }, mergeObjects $mergeObjects 操作会将参数中元素的内容进行合并，如果有重复，后面的值会覆盖前面的值，比如下面的这个文档 json { &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce82ab67f62529d94a84c&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; } }, 执行 $mergeObjects: [&quot;$aleft&quot;, &quot;$bright&quot;, &quot;$$ROOT&quot;] 操作后结果如下 json { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce82ab67f62529d94a84c&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; }, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; } replaceRoot $replaceRoot 将指定的文档提升到顶层，并丢弃顶层所有其他字段。 json [ { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;aleft&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: 12 }, &quot;bright&quot;: { &quot;_id&quot;: {&quot;$oid&quot;: &quot;624ce82ab67f62529d94a84c&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; }, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; } ] 至此，只要将 aleft 和 bright 两个参数删掉就得到了最后的结果，操作为 json { $project: {&quot;aleft&quot;: 0, &quot;bright&quot;: 0} } 结果示意如下 json [ { &quot;_id&quot;: {&quot;$oid&quot;: &quot;6247f1e253a1be11c3b88d8b&quot;}, &quot;id&quot;: 1, &quot;name&quot;: &quot;haha&quot; } ] 其他 MongoDB 中的 JOIN 操作还是十分复杂的，与 MySQL 不同， MongoDB 中的文档结构并没有限制，所以可以采用[嵌套文档](https://www.mongodb.com/docs/v4.2/tutorial/query-embedded-documents/)的方式将本来需要关联的数据保存在一起，从而避免 JOIN 操作">
                <h2><a href="mongodb-chu-tan.html">MongoDB 初探</a></h2>
                <div class="post-date">2022-04</div>
                <div class="excerpt">MongoDB 初探

对于已经熟悉 MySQL 的同学来说，初次接触 MongoDB 可能会不习惯它的语法，本篇文章将通过一个简单的示例带你入门 MongoDB。

 准备

对于 MongoDB 新手，可以借助 DataGrip 来学习MongoDB 语法。在 MongoDB 中实现准备好两个表 &quot;old&quot; 和 &quot;new&quot;，并随意插入一些数据

js
db.createCollection(&quot;...</div>
            </div>
            <div class="post-item" data-title="ClashForWindows TAP 模式无法正常连接网络" data-content="ClashForWindows 正常情况下只能代理通过 Http 或 Socks 代理工作。这两种协议工作在网络模型中的较高层级，可能无法代理系统全部的流量，比如对 SSH 或 WSL 等不起作用，使用时需要对这些应用单独配置。其实下面这几个选项可以让 ClashForWindows 有能力在 TCP/IP 层级工作，从而代理系统全部流量，具体的教程参见[官方文档](https://docs.cfw.lbyczf.com/contents/tun.htmlwindows) 这里主要提一下通过官方文档操作之后无法正常代理的情况，这种情况 GitHub 的 issue 上已经有了解决方案，[链接](https://github.com/Fndroid/clash_for_windows_pkg/issues/1243)。如果你也连不上网，不妨排查一下网卡的驱动或相关应用 使用上述方法代理系统全部流量时，可以关闭 ClashForWindows 的 System Proxy 开关，也会正常工作。 需要提及一下，这种方法虽然可以代理全部系统流量，看起来十分强大，但它的性能不如直接使用 Http 或 Socks 代理，所以还是要看情况使用不同的代理方案。">
                <h2><a href="clashforwindows-tap-mo-shi-wu-fa-zheng-chang-lian-jie-wang-luo.html">ClashForWindows TAP 模式无法正常连接网络</a></h2>
                <div class="post-date">2022-02</div>
                <div class="excerpt">ClashForWindows 正常情况下只能代理通过 Http 或 Socks 代理工作。这两种协议工作在网络模型中的较高层级，可能无法代理系统全部的流量，比如对 SSH 或 WSL 等不起作用，使用时需要对这些应用单独配置。其实下面这几个选项可以让 ClashForWindows 有能力在 TCP/IP 层级工作，从而代理系统全部流量，具体的教程参见[官方文档](https://docs.cf...</div>
            </div>
            <div class="post-item" data-title="Java 函数式编程详解" data-content="概要 首先一个简单的示例展示一下什么是函数式编程 假设我们有一个「Person」列表 java List&lt;Person people &#x3D; List.of( new Person(&quot;John&quot;, MALE), new Person(&quot;Maria&quot;, FEMALE), new Person(&quot;Aisha&quot;, FEMALE), new Person(&quot;Alex&quot;, MALE), new Person(&quot;Alice&quot;, FEMALE) ); 「Person」的定义如下 java private record Person(String name, Gender gender) {} enum Gender { MALE, FEMALE } 如果我们想在列表中找到 FEMALE，我们可以使用这样的命令式方法 java List&lt;Person females &#x3D; new ArrayList&lt;(); for (Person person : people) { if (FEMALE.equals(person.gender)) { females.add(person); } } for (Person female : females) { System.out.println(female); } 但它在声明式方法中更简洁 java Predicate&lt;Person personPredicate &#x3D; person - FEMALE.equals(person.gender); var females2 &#x3D; people.stream().filter(personPredicate) .collect(Collectors.toList()); // .forEach(System.out::println); females2.forEach(System.out::println); --- 完整代码如下： java public class Main { public static void main(String[] args) { List&lt;Person people &#x3D; List.of( new Person(&quot;John&quot;, MALE), new Person(&quot;Maria&quot;, FEMALE), new Person(&quot;Aisha&quot;, FEMALE), new Person(&quot;Alex&quot;, MALE), new Person(&quot;Alice&quot;, FEMALE) ); System.out.println(&quot;Imperative approach&quot;); // Imperative approach List&lt;Person females &#x3D; new ArrayList&lt;(); for (Person person : people) { if (FEMALE.equals(person.gender)) { females.add(person); } } for (Person female : females) { System.out.println(female); } // Declarative approach System.out.println(&quot;Declarative approach&quot;); Predicate&lt;Person personPredicate &#x3D; person - FEMALE.equals(person.gender); var females2 &#x3D; people.stream().filter(personPredicate) .collect(Collectors.toList()); // .forEach(System.out::println); females2.forEach(System.out::println); } private record Person(String name, Gender gender) {} enum Gender { MALE, FEMALE } } Function and BiFunction Function 表示接受一个参数 \&lt;T\ 并产生结果 \&lt;R\ 的函数。 java Function&lt;T, R 以下是 Function 的一些例子 java static Function&lt;Integer, Integer incrementByOneFunction &#x3D; number - number + 1; static Function&lt;Integer, Integer multiplyBy10Function &#x3D; number - number 10; ---usage var increment2 &#x3D; incrementByOneFunction.apply(1); var multiply &#x3D; multiplyBy10Function.apply(increment2); 酷，如果你看不懂，那么我们之前用命令式编程是这么写的 java static int incrementByOne(int number) { return number + 1; } ---usage var increment &#x3D; incrementByOne(1); 更进一步，我们可以结合两个 Function java var addBy1AndThenMultiplyBy10 &#x3D; incrementByOneFunction.andThen(multiplyBy10Function); ---usage var ans &#x3D; addBy1AndThenMultiplyBy10.apply(4); BiFunction 表示一个接受两个参数并产生结果的函数。 作为对比，这是一个传统的二参数方法 java static int incrementByOneAndMultiply(int number, int numberToMultiplyBy) { return (number + 1) numberToMultiplyBy; } ---usage incrementByOneAndMultiply(4, 100); 在函数式编程中，我们这样写 java static BiFunction&lt;Integer, Integer, Integer incrementByOneAndMultiplyBiFunction &#x3D; (numberToIncrementByOne, numberToMultiplyBy) - (numberToIncrementByOne + 1) numberToMultiplyBy; ---usage incrementByOneAndMultiplyBiFunction.apply(4, 100); --- 完整代码 java public class _Function { public static void main(String[] args) { // Function takes 1 argument and produce 1 result var increment &#x3D; incrementByOne(1); System.out.println(increment); var increment2 &#x3D; incrementByOneFunction.apply(1); System.out.println(increment2); var multiply &#x3D; multiplyBy10Function.apply(increment2); System.out.println(multiply); var addBy1AndThenMultiplyBy10 &#x3D; incrementByOneFunction.andThen(multiplyBy10Function); var ans &#x3D; addBy1AndThenMultiplyBy10.apply(4); System.out.println(ans); // BiFunction takes 2 argument and produce 1 result System.out.println(incrementByOneAndMultiply(4, 100)); System.out.println(incrementByOneAndMultiplyBiFunction.apply(4, 100)); } static Function&lt;Integer, Integer incrementByOneFunction &#x3D; number - number + 1; static Function&lt;Integer, Integer multiplyBy10Function &#x3D; number - number 10; static int incrementByOne(int number) { return number + 1; } static BiFunction&lt;Integer, Integer, Integer incrementByOneAndMultiplyBiFunction &#x3D; (numberToIncrementByOne, numberToMultiplyBy) - (numberToIncrementByOne + 1) numberToMultiplyBy; static int incrementByOneAndMultiply(int number, int numberToMultiplyBy) { return (number + 1) numberToMultiplyBy; } } Consumer and BiConsumer Consumer 表示接受单个输入参数并且不返回结果的操作。与大多数其他 Functional interface 不同，Consumer 预计通过副作用进行操作。 我们的 Customer 定义如下 java static record Customer(String customerName, String customerPhoneNumber) {} ---usage var maria &#x3D; new Customer(&quot;Maria&quot;, &quot;99999&quot;); 在命令式编程中，我们这样编写代码 java static void greetConsumer(Customer customer) { System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + customer.customerPhoneNumber); } ---usage greetConsumer(maria); 在函数式编程中，我们这样编写代码 java static Consumer&lt;Customer greetCustomerConsumer &#x3D; customer - System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + customer.customerPhoneNumber); ---usage greetCustomerConsumer.accept(maria); BiConsumer 是 Consumer 的二参数版本，它表示一个接受两个输入参数并且不返回结果的操作。 我们通常编写下面这种命令式编程方法 java static void greetConsumerV2(Customer customer, boolean showPhoneNumber) { System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + (showPhoneNumber ? customer.customerPhoneNumber : &quot;&quot;)); } ---usage greetConsumerV2(maria, false); 这是函数式编程版本 java static BiConsumer&lt;Customer, Boolean greetCustomerConsumerV2 &#x3D; (customer, showPhoneNumber) - System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + (showPhoneNumber ? customer.customerPhoneNumber : &quot;&quot;)); ---usage greetCustomerConsumerV2.accept(maria, false); --- 全部代码 java public class _Consumer { public static void main(String[] args) { var maria &#x3D; new Customer(&quot;Maria&quot;, &quot;99999&quot;); // Normal java function greetConsumer(maria); // Consumer Functional interface greetCustomerConsumer.accept(maria); greetCustomerConsumerV2.accept(maria, false); greetConsumerV2(maria, false); } static BiConsumer&lt;Customer, Boolean greetCustomerConsumerV2 &#x3D; (customer, showPhoneNumber) - System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + (showPhoneNumber ? customer.customerPhoneNumber : &quot;&quot;)); static Consumer&lt;Customer greetCustomerConsumer &#x3D; customer - System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + customer.customerPhoneNumber); static void greetConsumer(Customer customer) { System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + customer.customerPhoneNumber); } static void greetConsumerV2(Customer customer, boolean showPhoneNumber) { System.out.println(&quot;Hello&quot; + customer.customerName + &quot;, thanks for registering phone number &quot; + (showPhoneNumber ? customer.customerPhoneNumber : &quot;&quot;)); } static record Customer(String customerName, String customerPhoneNumber) { } } Predicate Predicate 表示一个布尔值函数 在命令式编程中通过这样写达到相同目的 java static boolean isPhoneNumberValid(String phoneNumber) { return phoneNumber.startsWith(&quot;07&quot;) &amp;&amp; phoneNumber.length() &#x3D;&#x3D; 11; } ---usage var phoneNumberValid &#x3D; isPhoneNumberValid(&quot;07000000000&quot;); 在函数式编程中，你可以这样写 java static Predicate&lt;String isPhoneNumberValidPredicate &#x3D; phoneNumber - phoneNumber.startsWith(&quot;07&quot;) &amp;&amp; phoneNumber.length() &#x3D;&#x3D; 11; static Predicate&lt;String containsNumber3 &#x3D; phoneNumber - phoneNumber.contains(&quot;3&quot;); ---usage System.out.println(isPhoneNumberValidPredicate.test(&quot;09009877300&quot;)); System.out.println( &quot;Is phone number valid and contains number 3 &#x3D; &quot; + isPhoneNumberValidPredicate.and(containsNumber3).test(&quot;07009877300&quot;) ); var isPhoneNumberValidAndContainsNumber3 &#x3D; isPhoneNumberValidPredicate.or(containsNumber3); System.out.println( &quot;Is phone number valid or contains number 3 &#x3D; &quot; + isPhoneNumberValidAndContainsNumber3.test(&quot;07000000000&quot;) ); 还记得我们在概要中写的代码 stream().filter() 吗？ java var females2 &#x3D; people.stream().filter(person - FEMALE.equals(person.gender)) .collect(Collectors.toList()); filter 接收的参数就是 Predicate ，在 idea 中使用快捷键 「Ctrl + Alt + V」将它的参数提取成变量，我们就会看到 Predicate java Predicate&lt;Person personPredicate &#x3D; person - FEMALE.equals(person.gender); var females2 &#x3D; people.stream().filter(personPredicate) .collect(Collectors.toList()); --- 完整代码 java public class _Predicate { public static void main(String[] args) { System.out.println(&quot;Without predicate&quot;); var phoneNumberValid &#x3D; isPhoneNumberValid(&quot;07000000000&quot;); System.out.println(phoneNumberValid); System.out.println(isPhoneNumberValid(&quot;0700000000&quot;)); System.out.println(isPhoneNumberValid(&quot;09009877300&quot;)); System.out.println(&quot;With Predicate&quot;); System.out.println(isPhoneNumberValidPredicate.test(&quot;07000000000&quot;)); System.out.println(isPhoneNumberValidPredicate.test(&quot;0700000000&quot;)); System.out.println(isPhoneNumberValidPredicate.test(&quot;09009877300&quot;)); System.out.println( &quot;Is phone number valid and contains number 3 &#x3D; &quot; + isPhoneNumberValidPredicate.and(containsNumber3).test(&quot;07009877300&quot;) ); var isPhoneNumberValidAndContainsNumber3 &#x3D; isPhoneNumberValidPredicate.or(containsNumber3); System.out.println( &quot;Is phone number valid or contains number 3 &#x3D; &quot; + isPhoneNumberValidAndContainsNumber3.test(&quot;07000000000&quot;) ); } static boolean isPhoneNumberValid(String phoneNumber) { return phoneNumber.startsWith(&quot;07&quot;) &amp;&amp; phoneNumber.length() &#x3D;&#x3D; 11; } static Predicate&lt;String isPhoneNumberValidPredicate &#x3D; phoneNumber - phoneNumber.startsWith(&quot;07&quot;) &amp;&amp; phoneNumber.length() &#x3D;&#x3D; 11; static Predicate&lt;String containsNumber3 &#x3D; phoneNumber - phoneNumber.contains(&quot;3&quot;); } Supplier Supplier 不接收任何参数并提供一个结果 在命令式编程中我们可以这样写 java static String getDbConnectionUrl() { return &quot;jdbc://localhost:5432/users&quot;; } ---usage System.out.println(getDbConnectionUrl()); 函数式编程的版本 java static Supplier&lt;String getDbConnectionUrlSupplier &#x3D; () - &quot;jdbc://localhost:5432/users&quot;; static Supplier&lt;List&lt;String getDbConnectionListUrlSupplier &#x3D; () - List.of( &quot;jdbc://localhost:5432/users&quot;, &quot;jdbc://localhost:5432/customer&quot; ); ---usage System.out.println(getDbConnectionUrlSupplier.get()); System.out.println(getDbConnectionListUrlSupplier.get()); --- 完整代码 java public class _Supplier { public static void main(String[] args) { System.out.println(getDbConnectionUrl()); System.out.println(getDbConnectionUrlSupplier.get()); System.out.println(getDbConnectionListUrlSupplier.get()); } static String getDbConnectionUrl() { return &quot;jdbc://localhost:5432/users&quot;; } static Supplier&lt;String getDbConnectionUrlSupplier &#x3D; () - &quot;jdbc://localhost:5432/users&quot;; static Supplier&lt;List&lt;String getDbConnectionListUrlSupplier &#x3D; () - List.of( &quot;jdbc://localhost:5432/users&quot;, &quot;jdbc://localhost:5432/customer&quot; ); } Stream 首先将前文的定义 Persion 的代码复制过来 java private record Person(String name, Gender gender) { } enum Gender { MALE, FEMALE, PREFER_NOT_TO_SAY } List&lt;Person people &#x3D; List.of( new Person(&quot;John&quot;, MALE), new Person(&quot;Maria&quot;, FEMALE), new Person(&quot;Aisha&quot;, FEMALE), new Person(&quot;Alex&quot;, MALE), new Person(&quot;Alice&quot;, FEMALE), new Person(&quot;Bob&quot;, PREFER_NOT_TO_SAY) ); 通过 Stream 来调用 java people.stream() .map(Person::name) .mapToInt(String::length) // .collect(Collectors.toSet()) .forEach(System.out::println); 我们可以把每一步的参数提取成变量，方便观察它们的类型 java Function&lt;Person, String personStringFunction &#x3D; Person::name; ToIntFunction&lt;String length &#x3D; String::length; IntConsumer println &#x3D; System.out::println; people.stream() .map(personStringFunction) .mapToInt(length) // .collect(Collectors.toSet()) .forEach(println); Stream 的其他用法 java Predicate&lt;Person personPredicate &#x3D; person - FEMALE.equals(person.gender); var containOnlyFemales &#x3D; people.stream() .allMatch(personPredicate); System.out.println(containOnlyFemales); var personHaveFemales &#x3D; people.stream() .anyMatch(personPredicate); // .noneMatch(personPredicate); System.out.println(personHaveFemales); Optional Optional 会改变你处理空指针的方式 示例： java var value &#x3D; Optional.ofNullable(null) .orElseGet(() - &quot;default value&quot;); var value2 &#x3D; Optional.ofNullable(&quot;hello&quot;) .orElseGet(() - &quot;default value&quot;); 示例2： java Supplier&lt;IllegalStateException exception &#x3D; () - new IllegalStateException(&quot;exception&quot;); var value3 &#x3D; Optional.ofNullable(&quot;hello&quot;) .orElseThrow(exception); 示例3： java Optional.ofNullable(&quot;john.gmail.com&quot;) .ifPresent(email - System.out.println(&quot;Sending email to &quot; + email)); Optional.ofNullable(null) .ifPresentOrElse(email - System.out.println(&quot;Sending email to &quot; + email), () - System.out.println(&quot;Can not send email&quot;)); --- 完整代码 java public class Main { public static void main(String[] args) { var value &#x3D; Optional.ofNullable(null) .orElseGet(() - &quot;default value&quot;); var value2 &#x3D; Optional.ofNullable(&quot;hello&quot;) .orElseGet(() - &quot;default value&quot;); System.out.println(value2); Supplier&lt;IllegalStateException exception &#x3D; () - new IllegalStateException(&quot;exception&quot;); var value3 &#x3D; Optional.ofNullable(&quot;hello&quot;) .orElseThrow(exception); Optional.ofNullable(&quot;john.gmail.com&quot;) .ifPresent(email - System.out.println(&quot;Sending email to &quot; + email)); Optional.ofNullable(null) .ifPresentOrElse(email - System.out.println(&quot;Sending email to &quot; + email), () - System.out.println(&quot;Can not send email&quot;)); } } Combinator Pattern 我们有一个 Customer 类定义如下 java public record Customer( String name, String email, String phoneNumber, LocalDate dob ) {} ---usage Customer customer &#x3D; new Customer( &quot;Alice&quot;, &quot;alice@gmail.com&quot;, &quot;+089998879&quot;, LocalDate.of(2000, 1, 1) ); 我们想验证此人的信息是否合法。在命令式编程中，我们可以这样验证 java public class CustomerValidatorService { private boolean isEmailValid(String email) { return email.contains(&quot;@&quot;); } private boolean isPhoneNumberValid(String phoneNumber) { return phoneNumber.startsWith(&quot;+0&quot;); } private boolean isAdult(LocalDate dob) { return Period.between(dob, LocalDate.now()).getYears() 16; } public boolean isValid(Customer customer) { return isEmailValid(customer.email()) &amp;&amp; isPhoneNumberValid(customer.phoneNumber()) &amp;&amp; isAdult(customer.dob()); } } ---usage System.out.println(new CustomerValidatorService().isValid(customer)); 可以看到，当我们需要添加验证项或者需要根据不同的用户启用不同的验证策略时，上面的方法需要改动太多的代码。这种方法的另一个缺点是：当验证失败时，我们无法知道对象的哪个属性没有通过验证，该方法只是返回一个失败的结果，这个结果并不包含细节。 我这里介绍的解决方案叫做 Combinator Pattern 为了能够返回方法的详细信息，我们首先定义一个枚举类 java enum ValidationResult { SUCCESS, PHONE_NUMBER_NOT_VALID, EMAIL_NOT_VALID, IS_NOT_AN_ADULT } 我们使用 CustomerRegistrationValidator interface 扩展 Functional interface java public interface CustomerRegistrationValidator extends Function&lt;Customer, ValidationResult { static CustomerRegistrationValidator isEmailValid() { return customer - customer.email().contains(&quot;@&quot;) ? SUCCESS : EMAIL_NOT_VALID; } static CustomerRegistrationValidator isPhoneNumberValid() { return customer - customer.phoneNumber().startsWith(&quot;+0&quot;) ? SUCCESS : PHONE_NUMBER_NOT_VALID; } static CustomerRegistrationValidator isAnAdult() { return customer - Period.between(customer.dob(), LocalDate.now()).getYears() 16 ? SUCCESS : IS_NOT_AN_ADULT; } / test lazy load / static CustomerRegistrationValidator printSomething() { return customer -{ System.out.println(&quot;print something&quot;); return SUCCESS; }; } default CustomerRegistrationValidator and (CustomerRegistrationValidator other) { return customer - { ValidationResult result &#x3D; this.apply(customer); return result.equals(SUCCESS) ? other.apply(customer) : result; }; } enum ValidationResult { SUCCESS, PHONE_NUMBER_NOT_VALID, EMAIL_NOT_VALID, IS_NOT_AN_ADULT } } 用法很简单 java var result &#x3D; isEmailValid() .and(isPhoneNumberValid()) .and(isAnAdult()) .apply(customer); System.out.println(result); if (result !&#x3D; ValidationResult.SUCCESS) { throw new IllegalStateException(result.name()); } 使用这种方法，我们可以灵活地组合多个验证。当验证失败时，该方法会返回失败的原因 此外，它是延迟加载，也就是直到调用 apply() 时才会真正执行 java var result2 &#x3D; isEmailValid() .and(isPhoneNumberValid()) .and(isAnAdult()) .and(printSomething()); System.out.println(&quot;not load before apply()&quot;); result2.apply(customer); --- 完整代码 调用方法 java public class Main { public static void main(String[] args) { Customer customer &#x3D; new Customer( &quot;Alice&quot;, &quot;alice@gmail.com&quot;, &quot;+089998879&quot;, LocalDate.of(2000, 1, 1) ); System.out.println(new CustomerValidatorService().isValid(customer)); // If valid we can store customer in db // ... // Using combinator pattern var result &#x3D; isEmailValid() .and(isPhoneNumberValid()) .and(isAnAdult()) .apply(customer); System.out.println(result); if (result !&#x3D; ValidationResult.SUCCESS) { throw new IllegalStateException(result.name()); } // Lazy lode var result2 &#x3D; isEmailValid() .and(isPhoneNumberValid()) .and(isAnAdult()) .and(printSomething()); System.out.println(&quot;not load before apply()&quot;); result2.apply(customer); } } 命令式编程 java public class CustomerValidatorService { private boolean isEmailValid(String email) { return email.contains(&quot;@&quot;); } private boolean isPhoneNumberValid(String phoneNumber) { return phoneNumber.startsWith(&quot;+0&quot;); } private boolean isAdult(LocalDate dob) { return Period.between(dob, LocalDate.now()).getYears() 16; } public boolean isValid(Customer customer) { return isEmailValid(customer.email()) &amp;&amp; isPhoneNumberValid(customer.phoneNumber()) &amp;&amp; isAdult(customer.dob()); } } 函数式编程 java public interface CustomerRegistrationValidator extends Function&lt;Customer, ValidationResult { static CustomerRegistrationValidator isEmailValid() { return customer - customer.email().contains(&quot;@&quot;) ? SUCCESS : EMAIL_NOT_VALID; } static CustomerRegistrationValidator isPhoneNumberValid() { return customer - customer.phoneNumber().startsWith(&quot;+0&quot;) ? SUCCESS : PHONE_NUMBER_NOT_VALID; } static CustomerRegistrationValidator isAnAdult() { return customer - Period.between(customer.dob(), LocalDate.now()).getYears() 16 ? SUCCESS : IS_NOT_AN_ADULT; } / test lazy load / static CustomerRegistrationValidator printSomething() { return customer -{ System.out.println(&quot;print something&quot;); return SUCCESS; }; } default CustomerRegistrationValidator and (CustomerRegistrationValidator other) { return customer - { ValidationResult result &#x3D; this.apply(customer); return result.equals(SUCCESS) ? other.apply(customer) : result; }; } enum ValidationResult { SUCCESS, PHONE_NUMBER_NOT_VALID, EMAIL_NOT_VALID, IS_NOT_AN_ADULT } } entity java public record Customer( String name, String email, String phoneNumber, LocalDate dob ) {} Callbacks 由于 Java 的函数式接口，我们现在可以像 JavaScript 一样使用 callback 在 JavaScript 中，我们像这样定义带有回调的函数 jsx function hello(firstName, lastName,callback) { console.log(firstName); if (lastName) { console.log(lastName); } else { callback(); } } 我们可以在 Chrome 控制台中调用它 jsx hello(&quot;john&quot;, null, function(){console.log(&quot;no lastname provided&quot;)}) 现在我们可以在 Java 中做同样的事情 java static void hello(String firstName, String lastName, Consumer&lt;String callback) { System.out.println(firstName); if (lastName !&#x3D; null) { System.out.println(lastName); } else { callback.accept(firstName); } } static void hello2(String firstName, String lastName, Runnable callback) { System.out.println(firstName); if (lastName !&#x3D; null) { System.out.println(lastName); } else { callback.run(); } } usage java hello(&quot;John&quot;, &quot;Montana&quot;, null); hello(&quot;John&quot;, null, value - { System.out.println(&quot;no lastName provided for &quot; + value); }); hello2(&quot;John&quot;, null, () - System.out.println(&quot;no lastName provided&quot;)); --- 完整代码 java public class Callbacks { public static void main(String[] args) { hello(&quot;John&quot;, &quot;Montana&quot;, null); hello(&quot;John&quot;, null, value - { System.out.println(&quot;no lastName provided for &quot; + value); }); hello2(&quot;John&quot;, null, () - System.out.println(&quot;no lastName provided&quot;)); } static void hello(String firstName, String lastName, Consumer&lt;String callback) { System.out.println(firstName); if (lastName !&#x3D; null) { System.out.println(lastName); } else { callback.accept(firstName); } } static void hello2(String firstName, String lastName, Runnable callback) { System.out.println(firstName); if (lastName !&#x3D; null) { System.out.println(lastName); } else { callback.run(); } } / Callback function in js: function hello(firstName, lastName,callback) { console.log(firstName); if (lastName) { console.log(lastName); } else { callback(); } } Invoke it: hello(&quot;john&quot;, null, function(){console.log(&quot;no lastname provided&quot;)}) / } 函数式编程的特性 - 无状态 - 纯函数 - 无副作用 - 高阶特性 - 函数将一个或多个函数作为参数。 - 函数返回另一个函数作为结果。">
                <h2><a href="java-han-shu-shi-bian-cheng-xiang-jie.html">Java 函数式编程详解</a></h2>
                <div class="post-date">2021-09</div>
                <div class="excerpt">概要

首先一个简单的示例展示一下什么是函数式编程

假设我们有一个「Person」列表

java
List&lt;Person people &#x3D; List.of(
        new Person(&quot;John&quot;, MALE),
        new Person(&quot;Maria&quot;, FEMALE),
        new Person(&quot;Aisha&quot;, FEMALE),
        new...</div>
            </div>
            <div class="post-item" data-title="位运算符总结" data-content="位运算符 &lt;&lt; signed &lt;&lt;&lt; unsigned signed unsigned | bitwise or &amp; bitwise and bitwise not ^ bitwise xor XOR Non-rounding addition x ^ x &#x3D; 0 x ^ 1s &#x3D; x // 注： 1s &#x3D; 0 x ^ (x) &#x3D; 1s c &#x3D; a ^ b 👉 a ^ c &#x3D; b, b ^ c &#x3D; a // 交换两个数 a ^ b ^ c &#x3D; a ^ (b ^ c) &#x3D; (a ^ b) ^ c // associative 指定位置的位运算 - 将 x 最右边的 n 位清零：x &amp; (0 &lt;&lt; n) - 获取 x 的第 n 位值（0 或者 1）： (x n) &amp; 1 - 获取 x 的第 n 位的幂值：x &amp; (1 &lt;&lt; n) - 仅将第 n 位置为 1：x | (1 &lt;&lt; n) - 仅将第 n 位置为 0：x &amp; ( (1 &lt;&lt; n)) - 将 x 最高位至第 n 位（含）清零：x &amp; ((1 &lt;&lt; n) - 1) 应用 判断奇偶： - x % 2 &#x3D;&#x3D; 1 — (x &amp; 1) &#x3D;&#x3D; 1 - x % 2 &#x3D;&#x3D; 0 — (x &amp; 1) &#x3D;&#x3D; 0 x 1 — x / 2 - 即： x &#x3D; x / 2; — x &#x3D; x 1; - mid &#x3D; (left + right) / 2; — mid &#x3D; (left + right) 1; X &#x3D; X &amp; (X-1) 清零最低位的 1 X &amp; -X &#x3D; 得到最低位的 1 X &amp; X &#x3D; 0 LeetCode - [https://leetcode-cn.com/problems/number-of-1-bits/](https://leetcode-cn.com/problems/number-of-1-bits/) - [https://leetcode-cn.com/problems/power-of-two/](https://leetcode-cn.com/problems/power-of-two/) - [https://leetcode-cn.com/problems/reverse-bits/](https://leetcode-cn.com/problems/reverse-bits/) - [https://leetcode-cn.com/problems/n-queens/description/](https://leetcode-cn.com/problems/n-queens/description/) - [https://leetcode-cn.com/problems/n-queens-ii/description/](https://leetcode-cn.com/problems/n-queens-ii/description/)">
                <h2><a href="binary-algorithm.html">位运算符总结</a></h2>
                <div class="post-date">2021-04</div>
                <div class="excerpt">位运算符

&lt;&lt; signed

&lt;&lt;&lt; unsigned

 signed

 unsigned

| bitwise or

&amp; bitwise and

 bitwise not

^ bitwise xor

 XOR

Non-rounding addition


x ^ x &#x3D; 0
x ^ 1s &#x3D; x // 注： 1s &#x3D; 0
x ^ (x) &#x3D; 1s
c &#x3D; a ^ b 👉 a...</div>
            </div>
            <div class="post-item" data-title="手把手教你读一个 Java 文件的字节码" data-content="想要读懂 Java 的字节码其实没那么难。当然，如果你有汇编语言的经验就会更好上手。本文手把手教你阅读一个简单 Java 文件的字节码。 如何得到字节码？ 以下面这段示例代码为例，他存放在一个包中： java package demo.a public class B{ ... } 通过下面这几个方法就可以查看代码的字节码： 方法 1 、命令行 相关命令如下 java javac demo/a/B.java // 编译 jvavp -c demo.a.B // 输出字节码 javap -c -verbose demo.a.B // 详细输出 方法 2 、idea 插件 下载个插件：「jclasslib Bytecode Viewer」，网址如下 [https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer](https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer) 安装该插件后，首先编译代码，然后 菜单 👉 「view」 👉 「Show Bytecode With jclasslib」 结果如下： 实验代码 我们使用下面这段代码，你可以将其输入 IDE 中 java import java.util.ArrayList; import java.util.List; public class Hello { public static void main(String[] args) { int num1 &#x3D; 1; int num2 &#x3D; 130; int num3 &#x3D; num1 + num2; int num4 &#x3D; num2 - num1; int num5 &#x3D; num1 num2; int num6 &#x3D; num2 / num1; final int num7 &#x3D; 5; Integer num88 &#x3D; 6; //看装箱指令 if(num88 &#x3D;&#x3D; 0){ System.out.println(num1); } List&lt;Integer nums &#x3D; new ArrayList&lt;(); nums.add(1); nums.add(2); for (int num : nums){ System.out.println(num); } if (nums.size() &#x3D;&#x3D; num2) { System.out.println(num2); } } } 下面是由 idea 反编译得到的代码，可以观察到 for 循环被改成了 while java // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class Hello { public Hello() { } public static void main(String[] args) { int num1 &#x3D; 1; int num2 &#x3D; 130; int var10000 &#x3D; num1 + num2; var10000 &#x3D; num2 - num1; var10000 &#x3D; num1 num2; var10000 &#x3D; num2 / num1; int num7 &#x3D; true; Integer num88 &#x3D; 6; if (num88 &#x3D;&#x3D; 0) { System.out.println(num1); } List&lt;Integer nums &#x3D; new ArrayList(); nums.add(1); nums.add(2); Iterator var10 &#x3D; nums.iterator(); while(var10.hasNext()) { int num &#x3D; (Integer)var10.next(); System.out.println(num); } if (nums.size() &#x3D;&#x3D; num2) { System.out.println(num2); } } } 阅读字节码 为了方便解释，我将字节码文件拆成小段，首先使用下面这个命令输出字节码 bash PS C:\Users\cedar\Desktop\ReadBytecode\code\target\classes javap -c .\Hello.class 一开始就说明了这是「Hello.java」的字节码 java Compiled from &quot;Hello.java&quot; public class Hello { 紧接着自动创建了无参构造方法，调用了父类 Object 的初始化函数。 aload_0 是说把本地变亮表位置 0 的对象加载出来，而这个位置保存的是对自身的引用。 你会发现字节码每条命令前面也有一个数字，比如 0: aload_0 前面有一个 0 ，它代表 aload_0 这条指令在第 0 个位置。接着观察 4: return，它的位置怎么突然变成 4 了？那是因为 invokespecial 这个指令还有两个输入参数，一共占用三个字节 java -- 字节码 public Hello(); Code: 0: aload_0 1: invokespecial 1 // Method java/lang/Object.&quot;&lt;init&quot;:()V 4: return 1: invokespecial 1 的 1，代表常量池位置 1.常量池通过 javap -c -verbose demo.a.B 就可以显示出来，如下所示 bash Constant pool: 1 &#x3D; Methodref 15.48 // java/lang/Object.&quot;&lt;init&quot;:()V 2 &#x3D; Methodref 12.49 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 3 &#x3D; Methodref 12.50 // java/lang/Integer.intValue:()I ...... 接下来就是 main 方法了，还记得我们在 main 方法中干了什么吗 java // 源码 int num1 &#x3D; 1; int num2 &#x3D; 130; int num3 &#x3D; num1 + num2; int num4 &#x3D; num2 - num1; int num5 &#x3D; num1 num2; int num6 &#x3D; num2 / num1; final int num7 &#x3D; 5; Integer num88 &#x3D; 6; 它对应的字节码是下面这样的，具体内容我已经标注出来了，稍微解释一下 iconst_1 ，代表常量 int 1 ，也就是代码中有个常量 「1」加载到栈顶 java public static void main(java.lang.String[]); Code: -- 初始化 num1 &#x3D; 1;保存到变量表 1 0: iconst_1 1: istore_1 -- 初始化 num2 &#x3D; 130; 保存到 变量表2，以下同理 2: sipush 130 5: istore_2 -- 计算 num3(匿名了) &#x3D; num1 + num2; 6: iload_1 7: iload_2 8: iadd 9: istore_3 -- 计算 num4(匿名了) &#x3D; num2 - num1; 10: iload_2 11: iload_1 12: isub 13: istore 4 -- 计算 num5(匿名了) &#x3D; num1 num2; 15: iload_1 16: iload_2 17: imul 18: istore 5 -- 计算 num6(匿名了) &#x3D; num2 / num1; 20: iload_2 21: iload_1 22: idiv 23: istore 6 -- final int num7 &#x3D; 5; 25: iconst_5 26: istore 7 -- Integer num88 &#x3D; 6; 28: bipush 6 30: invokestatic 2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 33: astore 8 然后是这个 if 语句 java if (num88 &#x3D;&#x3D; 0) { System.out.println(num1); } 注意上文 num88 被保存到变量表位置 8，所以此处把位置 8 加载出来 java -- 字节码 35: aload 8 37: invokevirtual 3 // Method java/lang/Integer.intValue:()I 40: ifne 50 -- 如果不等于 0 就跳转到 50 43: getstatic 4 // Field java/lang/System.out:Ljava/io/PrintStream; 46: iload_1 -- 存储 num1 的地方 47: invokevirtual 5 // Method java/io/PrintStream.println:(I)V 然后我们操作了一个 List java // 源码 List&lt;Integer nums &#x3D; new ArrayList&lt;(); nums.add(1); nums.add(2); java -- 初始化 List 对象 50: new 6 // class java/util/ArrayList 53: dup -- 把栈顶的值复制一份再压回去，此时栈顶有两份一样的值，分别被 54 和 57 指令消耗了 54: invokespecial 7 // Method java/util/ArrayList.&quot;&lt;init&quot;:()V 57: astore 9 -- 将初始化的对象存到寄存器 9 -- list - add(1); 59: aload 9 61: iconst_1 62: invokestatic 2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 65: invokeinterface 8, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 70: pop -- 丢弃了 add 返回值 -- list - add(2) 71: aload 9 73: iconst_2 74: invokestatic 2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 77: invokeinterface 8, 2 // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z 82: pop -- 丢弃了 add 返回值 遍历 List ，这里 JVM 把 for 改成了 while java // 源代码 for (int num : nums){ System.out.println(num); } //被 JVM 该成如下代码 Iterator var10 &#x3D; nums.iterator(); while(var11.hasNext()) { int num &#x3D; (Integer)var11.next(); System.out.println(num); } java -- 获取迭代器 83: aload 9 85: invokeinterface 9, 1 // InterfaceMethod java/util/List.iterator:()Ljava/util/Iterator; 90: astore 10 -- 92: aload 10 94: invokeinterface 10, 1 // InterfaceMethod java/util/Iterator.hasNext:()Z 99: ifeq 128 -- 如果等于 0，跳转到 128 -- 获取 next() 并打印 102: aload 10 104: invokeinterface 11, 1 // InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object; 109: checkcast 12 // class java/lang/Integer -- 检查对象是否为给定类型 112: invokevirtual 3 // Method java/lang/Integer.intValue:()I 115: istore 11 117: getstatic 4 // Field java/lang/System.out:Ljava/io/PrintStream; 120: iload 11 122: invokevirtual 5 // Method java/io/PrintStream.println:(I)V 125: goto 92 最后我们写了个 if java // 源码 if (nums.size() &#x3D;&#x3D; num2) { System.out.println(num2); } java -- 如果 list.size() &#x3D;&#x3D; num2; 打印 num2 128: aload 9 130: invokeinterface 13, 1 // InterfaceMethod java/util/List.size:()I 135: iload_2 136: if_icmpne 146 139: getstatic 4 // Field java/lang/System.out:Ljava/io/PrintStream; 142: iload_2 143: invokevirtual 5 // Method java/io/PrintStream.println:(I)V 146: return } 小结 Java 的字节码还是要比汇编简单一些。 这里再提一点，当要初始化一个 int 时（在 JVM 中：bool，byte，char，short 都是 int），根据不同的数字所占的位数不同，分别需要如下几个命令，方括号中给出了命令适用的范围 - iconst: [-1, 5] - bipush: [-128, 127] - sipush: [-32768, 32767] - idc: any int value --- - [https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html](https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html)">
                <h2><a href="shou-ba-shou-jiao-ni-du-yi-ge-java-wen-jian-de-zi-jie-ma.html">手把手教你读一个 Java 文件的字节码</a></h2>
                <div class="post-date">2021-03</div>
                <div class="excerpt">想要读懂 Java 的字节码其实没那么难。当然，如果你有汇编语言的经验就会更好上手。本文手把手教你阅读一个简单 Java 文件的字节码。

 如何得到字节码？

以下面这段示例代码为例，他存放在一个包中：

java
package demo.a
public class B{
    ...
}


通过下面这几个方法就可以查看代码的字节码：

 方法 1 、命令行

相关命令如下

java
...</div>
            </div>
            <div class="post-item" data-title="配置 WSL2 使用 Windows 代理上网" data-content="在 Windows 上设置好代理，连上了谷歌开开心心，但是 WSL 2 不能共享 Windows 的代理策略，如果在 WSL 上再装一个代理软件那可太麻烦了，所以得想想办法。 其实办法还挺简单的，可能有的同学不知道，在一个局域网下如果有一台机器配置好了代理，那么这个代理是可以共享给这个局域网下的其他设备的，比较类似软路由哈！ 具体方法如下： Windows 端 这里以 Clash 为例，打开 Allow LAN 选项，如下图所示。如果你使用其他软件，那可能是叫「网关模式」、「允许来自局域网的链接」或者其它的什么，都是一个东西，打开就好了，注意打开这个选项后你的电脑就可以代理整个局域网内的机器了，虽然其他的机器还需要额外的配置，但也还是注意安全。 对于 Clash 来说，这个选项是一次性的，下次开机它就关了，不过可以在配置文件里改，通常文件的开头就是。如下图，改成 true 就行。 开启这个选项后，仔细找找，你会找到一个 IP 地址和一个端口号，IP 其实就是本机 IP 啦，这两个数一会有用。 Clash 这个端口 http 和 socks 通用 注意如果后文配置后没有效果，那可能是 Windows 防火墙的锅，快去配置防火墙放行 Clash WSL 2 端 说是 WSL 2，其实其他的手机电脑都能连上，就在网络设置或者 WiFi 设置那有个配置代理，把上面得到的 IP 和端口填上就行。 下面就说说在 WSL 2 下怎么操作吧！ bash 获取主机 IP 主机 IP 保存在 /etc/resolv.conf 中 export hostip&#x3D;$(cat /etc/resolv.conf |grep -oP &#x27;(?&lt;&#x3D;nameserver\ ).&#x27;) Q: 以上似乎会定位到默认网关 192.168.3.1 A: 切换到 WSL2 bash export https_proxy&#x3D;&quot;http://${hostip}:7890&quot;; export http_proxy&#x3D;&quot;http://${hostip}:7890&quot;; 注意修改成你的端口 如果是 socket5 协议的话 bash export http_proxy&#x3D;&quot;socks5://${hostip}:7890&quot; export https_proxy&#x3D;&quot;socks5://${hostip}:7890&quot; 如果端口一样就可以合并成一句话，http 的同理 bash export all_proxy&#x3D;&quot;socks5://${hostip}:7890&quot; 使用 curl 即可验证是否代理成功，如下有返回值说明成功 bash ➜ cedar curl google.com &lt;HTML&lt;HEAD&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text/html;charset&#x3D;utf-8&quot; &lt;TITLE301 Moved&lt;/TITLE&lt;/HEAD&lt;BODY &lt;H1301 Moved&lt;/H1 The document has moved &lt;A HREF&#x3D;&quot;http://www.google.com/&quot;here&lt;/A. &lt;/BODY&lt;/HTML 可以将上面命令选择你需要的添加到 .bashrc ，这样会让代理一直开启。 使用 zsh 应该保存到 /.zshrc 更新配置 bash source /.zshrc 或者添加如下，需要代理的时候输入 setss 即可设置代理，取消代理就 unsetss ，或者新开一个窗口。 下面第二条的长命令你好像得根据情况删掉一部分。 bash export hostip&#x3D;$(cat /etc/resolv.conf |grep -oP &#x27;(?&lt;&#x3D;nameserver\ ).&#x27;) alias setss&#x3D;&#x27;export https_proxy&#x3D;&quot;http://${hostip}:7890&quot;;export http_proxy&#x3D;&quot;http://${hostip}:7890&quot;;export all_proxy&#x3D;&quot;socks5://${hostip}:7890&quot;;&#x27; alias unsetss&#x3D;&#x27;unset all_proxy&#x27; 如下是我在 /.zshrc 中添加的配置文件 bash export hostip&#x3D;$(cat /etc/resolv.conf |grep -oP &#x27;(?&lt;&#x3D;nameserver\ ).&#x27;) alias setss&#x3D;&#x27;export all_proxy&#x3D;&quot;socks5://${hostip}:7890&quot;;&#x27; alias unsetss&#x3D;&#x27;unset all_proxy&#x27; 验证： bash ➜ cedar setss ➜ cedar curl google.com &lt;HTML&lt;HEAD&lt;meta http-equiv&#x3D;&quot;content-type&quot; content&#x3D;&quot;text/html;charset&#x3D;utf-8&quot; &lt;TITLE301 Moved&lt;/TITLE&lt;/HEAD&lt;BODY &lt;H1301 Moved&lt;/H1 The document has moved &lt;A HREF&#x3D;&quot;http://www.google.com/&quot;here&lt;/A. &lt;/BODY&lt;/HTML ➜ cedar unsetss ➜ cedar curl google.com curl: (28) Failed to connect to google.com port 80: Connection timed out">
                <h2><a href="pei-zhi-wsl-2-shi-yong-windows-dai-li-shang-wang.html">配置 WSL2 使用 Windows 代理上网</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">在 Windows 上设置好代理，连上了谷歌开开心心，但是 WSL 2 不能共享 Windows 的代理策略，如果在 WSL 上再装一个代理软件那可太麻烦了，所以得想想办法。

其实办法还挺简单的，可能有的同学不知道，在一个局域网下如果有一台机器配置好了代理，那么这个代理是可以共享给这个局域网下的其他设备的，比较类似软路由哈！


具体方法如下：
 Windows 端
这里以 Clash 为例，打...</div>
            </div>
            <div class="post-item" data-title="查看 Docker IP 的几种方法" data-content="使用 Docker 时常常需要知道某一容器的 IP，这是个挺烦人的事儿，本文介绍几种查看 Docker IP 的方法 在容器内部查看 bash cat /etc/hosts 会显示自己以及 –link 软连接的容器 IP 使用 docker inspect 命令 inspect 会列出容器详细信息 下面的命令任选其一 bash docker inspect --format &#x27;{{ .NetworkSettings.IPAddress }}&#x27; &lt;container-ID 上面这个我在 Win10-WSL2-Docker 上用不了 bash docker inspect &lt;container id docker inspect -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27; container_name_or_id 在 /.bashrc 中写一个 bash 函数 bash function docker_ip() { sudo docker inspect --format &#x27;{{ .NetworkSettings.IPAddress }}&#x27; $1 } source /.bashrc 然后： bash $ docker_ip &lt;container-ID 显示所有容器名称及其 IP 地址 bash docker inspect -f &#x27;{{.Name}} - {{.NetworkSettings.IPAddress }}&#x27; $(docker ps -aq) 如果使用 docker-compose 命令将是 bash docker inspect -f &#x27;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27; $(docker ps -aq) 显示所有容器 IP 地址 docker inspect --format&#x3D;&#x27;{{.Name}} - {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27; $(docker ps -aq) --- - https://blog.csdn.net/sannerlittle/article/details/77063800">
                <h2><a href="cha-kan-docker-ip-de-ji-zhong-fang-fa.html">查看 Docker IP 的几种方法</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">使用 Docker 时常常需要知道某一容器的 IP，这是个挺烦人的事儿，本文介绍几种查看 Docker IP 的方法

 在容器内部查看
bash
cat /etc/hosts

会显示自己以及 –link 软连接的容器 IP
 使用 docker inspect 命令
inspect 会列出容器详细信息


下面的命令任选其一
bash
docker inspect --format &#x27;{{ ....</div>
            </div>
            <div class="post-item" data-title="有趣的三次握手与四次挥手" data-content="最近研究了以下 TCP\IP 协议中的三次握手与四次挥手，下面我将我的收获分享给大家。 IP 协议是一种在两点间建立传输的基础协议，可以说几乎所有的其他协议都建立在 IP 所提供的基础服务上进行传输。但 IP 协议是一种不可靠的传输协议，它既不保证一方发送的数据包到达另一方的顺序，也不保证发送的数据包能够送达到另一方，也就是说通过 IP 协议传输可能会发生丢包和延时。在一些需要保证数据完整性的场景中，IP 协议的不可靠性显然是无法被接受的。 TCP 协议全称为传输控制协议（Transmission Control Protocol），它是建立在 IP 协议上的一种传输协议。其目的就是在 IP 提供的不可靠传输服务中，在两点间建立一个可靠的传输连接。其可靠性是建立在「失败重传」这一机制上的，也就是说：任何一方向另一方发送数据，都必须收到对方的确认回应，否则就重新传输。在 TCP 协议中，最著名的莫过于其建立连接时的「三次握手」与断开连接时的「四次挥手」，本文我们就一起探索一下这两个过程。 注意：这里的「三次握手」英文原文是 three-way handshik 或者 three-message handshake，即通过三个步骤 / 三条消息才能建立的握手机制，同理四次挥手也是如此。 三次握手 我们首先来思考一个问题：如何才能确认一个连接是可靠的？其实如果你经常逛知乎的话，应该会见到下面这个讨巧卖萌的解答方式： 「喂，你听得到吗？」&lt;br/ 「我听得到啊，你能听到我吗？」&lt;br/ 「我能听到你。」 没错，这就是一个简化了的 TCP 连接的建立过程。那么我们来分析一下这一简化的过程； 显而易见，如果我们想建立一个双向的、可靠的通讯，我们必须确认建立连接时双方的接收和发送数据的功能都是可用的，用上 TCP 中的术语，大概是下面这样。 相信你也发现了，为了减少一次通讯次数，我们会把上图的 ② 和 ③ 合并成一次， 你看，经过三步，一个简化的 TCP 连接就建立起来了，之后 A 和 B 就会互相传输数据。但是我们说过 IP 协议会发生丢包和延时，而三步握手仅仅是确认了双方接受和发送数据的功能是可用的，并没有解决 IP 协议丢包和延时带来的问题。那么 TCP 是怎么解决这一问题的呢？ 前文提到过，TCP 用来保证可靠性的方法是「失败重传」，我们可以从 A 机器向 B 机器发起连接请求的那条消息（即上图 ①）开始，将 A 发给 B 的所有消息按顺序标上序号，同时也将 B 发给 A 的所有消息按顺序标上序号，这样对方收到发来的消息就能根据序号分辨出顺序和丢包，如果发生丢包就可以要求重传。但在实际传输中，由于各个中间节点的配置不同，一个数据包在传输过程中可能被中间节点分成几份，所以实际中序号的意义是「这是我们所传输数据的第几个字节」。如下图所示 注意这里的序号并不是从 0 开始，其实用 0 表示初始值在编程中是普遍的做法，为什么在这里就不是这样了呢？这里我们考虑一下当 TCP 未能正常建立连接的情况。 我们将发起请求的 A 机器称为客户端，将接受请求的 B 机器称为服务端，通常服务端通过四个数据识别一条连接，即双方的 ip 地址和双方建立连接的端口号。假设客户端首先请求建立连接，然后发送了一个数据包（假设序号为 x）但是这个数据包在传输过程中发生了较大的延时，导致服务端认为连接中断，关闭了连接。紧接着同一个客户端再次发起请求，在刚建立连接的时候，之前延时的那个数据包碰巧到达了，而如果两次连接的端口一样的话，也就是说新连接建立时双方的 ip 地址和端口号都和老链接一样，这个来自老链接的数据包就可以轻松的蒙混过关，被服务端接受下来，这显然是不被允许的。 - 客户端：我想建立连接。 - 服务端：好！ - 客户端：发送第一个数据包 ① - ......（第一个数据包发生延时） - 服务端：奇怪怎么没动静了，断了连接吧 - ... - 客户端：奇怪，怎么断了。我想建立连接。 - 服务端：好！ - 数据包 ① 终于到了！ - 服务端：来数据了，我要收下 因此，每次建立连接的起始序号应该是不同的，也就是说我们需要一种随机数算法，保证生成的随机数在一个数据包的最大生存周期内不会重复。我们用这个随机数作为连接的起始序号，这样结合数据包的四元组（双方建立链接的 ip 和端口），就可以保证在数据包的最大生存周期内，每一个数据包的唯一性，以此避免发生混淆。通常这个起始序号有一个专用的的名字叫做 ISN (Initial Sequence Number)。 在实际情况中，客户端和服务端在建立连接时分别会生成自己的 ISN，然后通过建立连接的报文发送给对方，供对方确认是否丢包。 下面我们来看看 TCP 报文的格式 报文的第一行两个端口号各占两个字节，分别表示了源机器和目标机器的端口号，再加上 IP 报文中双方的 IP 地址即可组成之前所说的四元组。协议的第四行包括了 6 个控制位，这里我们主要关注其中的 SYN, ACK, FIN 这三个控制位。SYN 即 synchronize，在建立连接时使用，也就是我们所说的「听得到吗？」；ACK 表示 acknowledge，表示确认收到了消息，也就是我们所说的「听得到！」；FIN 表示 finish，在稍后讲述断开连接时会使用。 报文的第二行和第三行是序列号，各占 4 个字节。它们就是我们之前说的「序号」，seq 是指所发送数据包中数据部分第一个字节的序号，ack 是指期望收到来自对方的下一个数据包中数据部分第一个字节的序号。TCP 还规定，如果一方发送的 seq 序号为 x，那么就代表它已经收到了从建立连接开始到 x-1 的所有数据，有了这一机制，当接收方发送的确认数据在传输的过程中丢失时，数据发送方也能根据收到的部分确认数据推测出对方收到了多少数据，减少了发送方由于「误会」而造成的失败重传，能有效缓解网络拥挤的现象。 - 服务端：发送以 seq &#x3D; 101 开始，长度为 10 的数据包。 - 客户端：请发送以 seq &#x3D; 111 开始的数据包。 - 服务端：发送以 seq &#x3D; 111 开始，长度为 30 的数据包。 - ...假设数据包被中间节点拆分成 3 个小块 - 客户端：咦，怎么来了一个 seq 121 开始长度为 10 的数据包？ - 客户端：咦，怎么来了一个 seq 131 开始长度为 10 的数据包？ - 客户端：终于收到 seq &#x3D; 111 开始的数据包了，长度为 10，需要回 ACK &#x3D; 121。 - 客户端：不对。seq &#x3D; 121 开始的数据包我好像收到过，需要回 ACK &#x3D; 131 才对。 - 客户端：还不对。seq &#x3D; 131开始的数据包我也收到过，需要回 ACK &#x3D; 141 才对。 - 服务端：发送以 seq &#x3D; 141 开始，长度为 10 的数据包。 - 服务端：发送以 seq &#x3D; 151 开始，长度为 10 的数据包。 - 客户端：ack &#x3D; 151 - ...丢失 - 客户端：ack &#x3D; 161 - 服务端：只来了个 ack &#x3D; 161，我猜 seq &#x3D; 151 那个数据包也发送成功了。 由于 TCP 报头存在一些扩展字段，所以需要通过长度为四个 bit 的头部长度字段表示 TCP 报头的大小，这样接收方才能准确的计算出包中数据部分的开始位置。 接下来门就看看真正的三次握手。注意在请求连接的数据包中，由于不传输，SYN ACK 被当作数据部分第一个字节。 - 第一步 - A 将数据包中 SYN 置 1，表示希望建立连接 - 并生成第一个 seq（此时应叫 ISN）假设为 x，然后将这个数据包发送给对方。 - 第二步 - B 收到 A 发来的数据包后，通过 SYN 得知这是一个建立连接的数据包， - 于是生成一个相应包将 SYN 和 ACK 都置 1，表示对 A 的回应和询问， - 并将确认序号（ack）设置为 x+1，表示收到了 A 机器「SYN」这一字节数据，期望收到 A 的下一个数据包中第一个字节序号为 x+1。 - 并标记上自己的第一个 seq（此时叫 ISN），假设为 y，然后发送这个数据包。 - 第三步 - A 收到 B 的相应包后进行确认，将确认包中 ACK 置为 1 表示确认， - seq 置为 x+1（即对方期望的「下一个字节」）， - ack 置为 y+1（收到对方第 y 个字节的数据，期望收到下一个数据包中第一个字节序号为 y+1）. 说完了三次握手，我们再来看看 TCP 断开连接时的四次挥手 四次挥手 有了前面的基础，四次分手就简单的多了。首先是简化版本 看到这幅图可能你也明白了，TCP 的建立连接和断开连接都需要两轮问答，只不过建立连接的时候，② 和 ③ 可以被合并为一次通信。而在断开连接的时候，由于 A B 两台机器通常不会同时发送完数据，所以只能等待每一方发完数据时分别进行一轮确认。接下来看看带有序号的「正式版」 关于四次挥手我看到过一个分手的版本 - 男生：我们分手吧。 - 女生：好的，我的定西收拾完，发信息给你。（此时男生不能再拥抱女生了。） - 一个小时后... - 女生：我收拾好了，分手把。（此时，女生也不能再拥抱男生了。） - 男生：好的。（此时，双方约定经过 2 个月的过渡期，双方才可以分别找新的对象。） 可能你注意到了，双方最后有 2 个月的过渡期，在四次分手中也有这样的一个过渡期，它的时长为 2MSL。MSL（Maximum Segment Lifetime）中文可以译为「报文最大生存时间」，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL即两倍的MSL，在此期间，主动分手一方会进入一个名为 TIME_WAIT 的等待状态，也称为 2MSL 等待状态。 当 TCP 的一端发起主动关闭，在发出最后一个 ACK 包后，即第3次挥手完成后发送了第四次挥手的 ACK 包后就进入了 TIME_WAIT 状态，必须在此状态上停留两倍的 MSL 时间，等待 2MSL 时间主要目的是怕最后一个 ACK 包对方没收到，那么对方在超时后将重发第三次挥手的 FIN+ACK 包，主动关闭端接到重发的 FIN 包后可以再发一个 ACK 应答包，并且会重新计时。在 TIME_WAIT 状态时两端的端口不能使用，要等到 2MSL 时间结束才可继续使用。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被丢弃,因此 2MSL 等待状态的另一个用处是防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。 至此我们已经对 TCP 的三次握手与四次挥手有了初步的理解，后文会更加详细的说明在 TCP 的握手与挥手时双方的状态转换。">
                <h2><a href="you-qu-de-san-ci-wo-shou-yu-si-ci-hui-shou-1.html">有趣的三次握手与四次挥手</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">最近研究了以下 TCP\IP 协议中的三次握手与四次挥手，下面我将我的收获分享给大家。

IP 协议是一种在两点间建立传输的基础协议，可以说几乎所有的其他协议都建立在 IP 所提供的基础服务上进行传输。但 IP 协议是一种不可靠的传输协议，它既不保证一方发送的数据包到达另一方的顺序，也不保证发送的数据包能够送达到另一方，也就是说通过 IP 协议传输可能会发生丢包和延时。在一些需要保证数据完整性的场...</div>
            </div>
            <div class="post-item" data-title="文章排版指南" data-content="我们日常看文章的时候，其实已经在慢慢积累我们的审美意识，我们能分辨，哪篇推文看着舒服，哪篇文章看着辣眼睛。为了减少这种「辣眼睛」的情况出现，今天我就来谈谈关于文章排版的事情。 ▎博客排版 写博客的同学都知道，现在博客都是由 Markdown 排版。如果你还不知到 Markdown 的话就去学习一下吧，它可以很方便地帮助我们排版出漂亮的文章。但我们在写博文的时候，仍有一些细节是需要注意的。 空格 每次看到网页上的中文字和英文、数字、符号挤在一起，就会坐立不安，忍不住想在他们之间加个空格。 - 中英文之间需要加空格 eg. 大家可以微信搜一搜 solidSpoon 关注我。 - 中文与数字之间需要加空格 eg. 不知不觉，我已经写博客 3 个月了。 - 数字与单位之间需要加空格 eg. 我昨天买了一个 16 GB 的 U 盘。 - 完整的英文整句时标点后要加空格。 eg. Love me, love my dog. 但是也有一些例外。 - 度的标志、百分号不加空格 eg. 水的沸点是 100°。 eg. 我的手机还有 75％ 的电量。 - 全角标点与其他字符之间不加空格 eg. 大家好，我是 solidSpoon，欢迎访问我的博客。 标点 说到标点，不得不说下全角和半角，很多人可能不了解全角和半角的概念，这里顺便介绍下。 全角和半角是英文和中文的编码规范不同遗留下的问题，简单来说，全角占两个字节，半角占一个字节，你可以理解成中文汉子是全角，英文字母是半角，不过半角全角主要是针对标点符号来说的，中文标点占两个字节，英文标点占一个字节。体现在排版上的差异就是，全角字符屏幕打印宽度是两个，而半角字符屏幕打印宽度是一个，如中文逗号和英文逗号他们的显示分别是「，」和「,」。 - 使用全角中文标点 中文排版中所有的标点都应该使用中文全角中文标点 eg. 大家好，我是 solidSpoon。 - 遇到英文整句、特殊名词时使用半角标点。 eg. 乔布斯说过：「Stay hungry, stay foolish.」 eg. Facebook, Inc. - 使用直角引号 - 我国国家标准要求弯引号，但是个人建议在新媒体排版时使用直角引号。 eg. 「我去吃饭了」，它起身说到。 - 如果引号再使用引号使用直角双引号。 eg. 我对他说：「乔布斯说过：『Stay hungry, stay follish.』」 微软拼音输入特殊符号方法： 首先在中文输入界面输入 u 进入「u 模式输入」，然后跟着屏幕提示就可以找到你要输入的特殊符号了。 - eg. 中文界面输入 uubd 就可以找到直角引号。 其他 除以上之外，还有一些其他标准推荐大家使用的。 - 英文名词首字母尽量大写 eg. Google、Android、Facebook - 专有名词使用正确的大小写 eg. GitHub、iOS、iPhone XS Max、MacBook Pro - 首行不要缩进 关于首行不缩进可能有人不太同意，但是我要在这里解释下，在说明之前我们必须弄明白「首行缩进」的目的是什么。 「每段之前空两格」是我们从小学写作文就养成的习惯，也是正式文体的格式要求，其目的是为了区分自然段。 但是像我们现在接触的阅读，都是没有固定的格式要求的，如微信公众号、电子文档等，所以大家一般都采用「空出一行」进行自然段与自然段之间的区分，这种写作方式非常省事，而且很整齐。 所以，我认为这种应该是最科学的方式，只要没有明确的格式要求，写作的排版无须首行缩进。 ▎公众号排版 用 Markdown 写作的确很方便。那么对于「不那么方便」的微信公众号，除了上面的那些外，又有什么是需要注意的呢？ 大小 简单来说就是：标题要比正文大，正文要比标注大。 颜色 颜色搭配保持统一，个别字体使用特殊色强调，字体颜色尽量不超过三种，颜色不要选取太亮的颜色，例如纯黑，纯红，亮红配亮绿，都是不建议的，看久了眼睛难免会疲惫，不利于阅读。 建议使用字体颜色： - 标题：使用公众号常用色，或者直接取 logo 或者行业色 - 正文：选择亮度没这么高的字体，这是纯黑 000000 ，比较偏灰会更加适合阅读 595757 3f3f3f 等 - 批注：选择比正文亮度还低，更加浅的浅灰色，例如 595959 888888 d6d6d6 形态 和 word 编辑一样，公众号文字形态也可以做一些基本变化，例如 加粗、斜体、&lt;u下划线&lt;/u、删除线 等，常用的是加粗，以及有趣（戏多）的删除线。 对齐 对齐，可以说是拯救强迫症的最佳设置。这里推荐对齐方式为：两端对齐。 我们日常排版完会发现，因为句子的字符大小的原因，每行的最右边都会变得层次不齐，强迫症看着会非常的不舒服，这时候如果我们选择两端对齐，就会美观的多。 小符号 就像前面对标题的处理一样，简单的符号也能划分空间，也要常用引号，以此突出重点等 留白 在经过了文字的排版以后，整个版面的风格已经出来了，但是我们会发现，推文里字句的间距太密了，看久了眼睛很不舒服。其实，这都是因为：&lt;u 没有留白，没有呼吸感&lt;/u。 留白可以包括： - 页面边距 - 段 / 字 / 行间距 - 缩进 - 空行 页面边距 页面边距指的是推文与手机屏幕两侧的距离。 默认距离是 0，我们可以设置，让文字离屏幕远一点。我个人建议页边距设置为 0.5，或者 1，比较舒服。 段距 段落与段落之间，图片与文字之间，都可以使用段前距、段后距进行调整距离，当然也可以使用空格代替。 字间距 字体之间的距离太密，容易让人错过重点内容，调整文字间距会有意想不到的效果，呼吸感瞬间有了。和字间距一样，行间距是解放原有行与行之间的重要一步。 - 推荐参数：行间距 1.5 1.75、字间距 1 图片与表情包 适当的图片和表情可以增加阅读的兴趣 浮动设置 有的时候，我们会看到很多公众号通篇都是长图，而我们上传多图的时候，要么是图片太大上传不了，要么就是多图的时候出现空隙。这时候我们就只要让图片浮动就可以解决这个问题。">
                <h2><a href="wen-zhang-pai-ban-zhi-nan.html">文章排版指南</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">我们日常看文章的时候，其实已经在慢慢积累我们的审美意识，我们能分辨，哪篇推文看着舒服，哪篇文章看着辣眼睛。为了减少这种「辣眼睛」的情况出现，今天我就来谈谈关于文章排版的事情。

 ▎博客排版

写博客的同学都知道，现在博客都是由 Markdown 排版。如果你还不知到 Markdown
的话就去学习一下吧，它可以很方便地帮助我们排版出漂亮的文章。但我们在写博文的时候，仍有一些细节是需要注意的。

...</div>
            </div>
            <div class="post-item" data-title="搭建简单好用的笔记系统" data-content="你是不是也一直觉得 OneNote、印象笔记、有道云笔记等等工具用起来都有一点不太舒服。我只想用一个简单方便，到哪都能用的笔记系统，但是市面上常见的笔记软件越来越臃肿，小众良心的软件又担心它会不会死掉，这里我给你提供一个思路。 如果你想要一个全平台通用的、适合记笔记的文件格式，那么 Markdown 应该是一个不错的选择。Markdown 的语法简单、排版漂亮，配合像 Typora 这种优雅的编辑器能够在电脑端实现很棒的体验。 当然，Markdown 也有它的缺点。由于这种文件格式本身并不能保存图片，导致 Markdown 的使用者常常要自己想办法来解决全平台使用图片的问题。其中最省心的办法就是在类似阿里云、腾讯云这样大型的云服务商购买存储服务，配合 PicGo 这种小工具自己搭建一个图床，操作简单而且质量可靠。 更具体的操作方法你可以去搜索『阿里云 图床』这样的关键词。最后，使用坚果云这种全平台可用的同步盘来同步你的 Markdown 笔记。而且坚果云也有 Markdown 小工具，在手机和网页端浏览 Markdown 文件也比较方便。 希望你也喜欢这样的一种解决方案。 --- 题图由&lt;a href&#x3D;&quot;https://pixabay.com/zh/users/Monfocus-2516394/?utm_source&#x3D;link-attribution&amp;amp;utm_medium&#x3D;referral&amp;amp;utm_campaign&#x3D;image&amp;amp;utm_content&#x3D;1925752&quot;Monfocus&lt;/a在&lt;a href&#x3D;&quot;https://pixabay.com/zh/?utm_source&#x3D;link-attribution&amp;amp;utm_medium&#x3D;referral&amp;amp;utm_campaign&#x3D;image&amp;amp;utm_content&#x3D;1925752&quot;Pixabay&lt;/a上发布">
                <h2><a href="da-jian-jian-dan-hao-yong-de-bi-ji-xi-tong.html">搭建简单好用的笔记系统</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">你是不是也一直觉得 OneNote、印象笔记、有道云笔记等等工具用起来都有一点不太舒服。我只想用一个简单方便，到哪都能用的笔记系统，但是市面上常见的笔记软件越来越臃肿，小众良心的软件又担心它会不会死掉，这里我给你提供一个思路。

如果你想要一个全平台通用的、适合记笔记的文件格式，那么 Markdown 应该是一个不错的选择。Markdown 的语法简单、排版漂亮，配合像 Typora 这种优雅的编...</div>
            </div>
            <div class="post-item" data-title="怎么直观地给网页「P_图」" data-content="你肯定知道在浏览器中按下 F12 打开开发者工具，在其中修改源代码就可以更改网页上的任意内容。那么有没有办法可以不看源码，通过「所见即所得」的方式直接在页面上修改呢 下面这两个属性可以帮助我们实现这一想法： 1. 使用 contentEditable 属性 1. 使用 designMode 属性 这两个属性用来帮助开发人员创建网页端的富文本编辑器，因此如果我们将整个网页都应用这两个属性，都可以达到可视化编辑网页的效果。 javascript document.body.contentEditable&#x3D;&#x27;true&#x27;;document.designMode&#x3D;&#x27;on&#x27;; designMode 是 document 级别的属性 contentEditable 是元素级别的属性 当一个 HTML 文档被切换到 designMode 时，我们就可以使用 document.execCommand 方法，我们可以通过这个方法对文档中的内容添加粗体、斜体、缩进、对某段文字添加一个链接等等。 例如，下面的代码就会给选中的文本加上链接 javascript document.execCommand(&quot;CreateLink&quot;,false,&quot;http://www.baidu.com&quot;); 使用这些方法，我们就可以很容易的用可视化的方式改网页了。当然，你肯定不想在控制台敲这么长的命令，所以找一些可以在浏览器运行脚本的软件来简化这个过程。 这儿有一个简单的示例希望可以帮助到你 https://getquicker.net/sharedaction?code&#x3D;f7db1234-2681-4c6a-82a4-08d83ad18965">
                <h2><a href="zen-me-zhi-guan-di-gei-wang-ye-p-tu.html">怎么直观地给网页「P_图」</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">你肯定知道在浏览器中按下 F12 打开开发者工具，在其中修改源代码就可以更改网页上的任意内容。那么有没有办法可以不看源码，通过「所见即所得」的方式直接在页面上修改呢



下面这两个属性可以帮助我们实现这一想法：

1. 使用 contentEditable 属性
1. 使用 designMode 属性

这两个属性用来帮助开发人员创建网页端的富文本编辑器，因此如果我们将整个网页都应用这两个属性，...</div>
            </div>
            <div class="post-item" data-title="如何用正则表达式匹配 3 的倍数" data-content="问题背景 最近在知乎上看到这样一个问题『如何用正则表达式匹配 3 的倍数』，原帖给出的答案非常有意思，遂研究了一番 看一个数能否被 3 整除，最直接的办法就是将这个数用 3 除一下，如果余数是 0，那么这个数就可以被3 整除。然而正则并不具有计算的功能，正则算法的实现基于有穷状态自动机（finite automaton） 以下是一个简单的示例 这正则表达式 哈+嗝 的自动机，该正则表达式可以匹配一连串的『哈』紧接着一个『嗝』 该自动机从左到右遍历一个字符串。可以看到，自动机初始状态是 s0，当遇到一个『哈』时，其状态变为 s1。此时，如果后面的字符还是『哈』，那么该自动机的状态会不断地在 s0 和 s1 之间转换，直到遇到一个不是『哈』的字符，状态稳定在 s1。此时如果下一个字符是『嗝』，则自动机变为状态 s2，也就是说该自动机匹配到了一个指定的文本；如果是其他字符，则匹配失败，回到 s0。 我们常说一个正则表达式匹配到了文本，就是在文本中寻找一个字符串，可以让该正则表达式的自动机从起始状态转移到结束状态。如果我们要解决文章开头提出的问题，就要设计出合适的自动机。 设计自动机 我们来分析一下手动计算除法的过程 仔细观察上图，可以发现一个数被 3 除，余数只有 0，1，2 三种情况，此时被除数的下一位可以是 0 9 的任意一值，也即我们需要处理的范围只有 00 09，1029。 此时，我们已经有了一个自动机的雏形，它包括 A，B，C 三个状态 由于我们的规则只有 00 09，1029，共 30 种，所以可以直接将这些规则添加到自动机中。这个自动机开始状态和结束状态都是 A 对于前面的示例 522/3 ,在状态机中经过的路径如下，可以看到最终返回到了状态 A，表示 522 可以被 3 整除。 状态机转正则表达式 下面来看看如何将我们设计出的这个状态机转换为正则表达式。有一点需要注意，由于我们的状态机起始状态和终止状态都为 A，如果在开始状态什么事都不做，实际已经处于终止状态，也就是说我们的状态机可以匹配到空字符串。在下面的推导中，我将用『Ø』表示空字符串。 我们假定 A 是一个可以让状态机由终止状态转换到状态 A 的字符串，BC 类似。根据状态机可以列出如下三个方程 A &#x3D; A[0369] | B[258] | C[147] | Ø B &#x3D; A[147] | B[0369] | C[258] C &#x3D; A[258] | B[147] | C[0369] 要从这三个方程推导出我们想要的正则表达式需要下面两个技巧 技巧1：根据正则语言的特性给定如下形式的方程，和它的解，以下每个字母均代表一个正则表达式 L &#x3D; LU | V 解：L &#x3D; VU 我们将解带入原方程可验证它的正确性 VU &#x3D; VUU | V VU &#x3D; VU+ | V 技巧2：分配律 (U | V) A &#x3D; UA | VA 根据这两个技巧，推导过程如下，你可以暂时跳过这个推导过程 上述方程可以修改为： A &#x3D; (Ø | B[258] | C[147])[0369] (1) B &#x3D; (A[147] | C[258])[0369] (2) C &#x3D; (A[258] | B[147])[0369] (3) 将 (3) 代入 (1)(2) 得 A &#x3D; (Ø | B[258] | (A[258] | B[147])[0369][147])[0369] (4) B &#x3D; (A[147] | (A[258] | B[147])[0369][258])[0369] (5) 用分配律展开 (5) 中的竖线得到 B &#x3D; A[147][0369] | A[258][0369][258][0369] | B[147][0369][258][0369] &#x3D; B[147][0369][258][0369] | A[147][0369] | A[258][0369][258][0369] &#x3D; (A[147][0369] | A[258][0369][258][0369])([147][0369][258][0369]) &#x3D; A[147][0369]([147][0369][258][0369]) | A[258][0369][258][0369]([147][0369][258][0369]) 把它代入 (4) 得 A &#x3D; (Ø | B[258] | (A[258] | B[147])[0369][147])[0369] &#x3D; [0369] | B[258][0369] | (A[258] | B[147])[0369][147][0369] &#x3D; [0369] | B[258][0369] | A[258][0369][147][0369] | B[147][0369][147][0369] &#x3D; [0369] | B[258][0369] | A[258][0369][147][0369] | B[147][0369][147][0369] &#x3D; [0369] | A[147][0369]([147][0369][258][0369])[258][0369] | A[258][0369][258][0369]([147][0369][258][0369])[258][0369] | A[258][0369][147][0369] | A[147][0369]([147][0369][258][0369])[147][0369][147][0369] | A[258][0369][258][0369]([147][0369][258][0369])[147][0369][147][0369] &#x3D; A[...] | [0369] &#x3D; [0369] [...] &#x3D; [0369] ( [147][0369]([147][0369][258][0369])[258][0369] | [258][0369][258][0369]([147][0369][258][0369])[258][0369] | [147][0369]([147][0369][258][0369])[147][0369][147][0369] | [258][0369][258][0369]([147][0369][258][0369])[147][0369][147][0369] | [258][0369][147][0369] ) &#x3D; [0369] ( ([147][0369] | [258][0369][258][0369]) ([147][0369][258][0369]) ([258][0369] | [147][0369][147][0369]) | [258][0369][147][0369] ) 以上就是我们得到的正则表达式，我们去掉结果中的换行与空格，用 (?:) 消去不必要的子组，再加上断言 (?&lt;!\d) 与 (?!\d) 确保匹配整个数字，得到最终的正则表达式如下： (?&lt;!\d)[0369](?:(?:[147][0369]|[258][0369][258][0369])(?:[147][0369][258][0369])(?:[258][0369]|[147][0369][147][0369])|[258][0369][147][0369])(?!\d) 这是该正则表达式真正的自动机，该自动机将开始状态与结束状态区分开了 有点儿复杂，但是我们知道 3 的倍数有一个特性：如果一个数可以被 3 整除，那么这个数各位之和也能被 3 整除，反之也成立。我们在各位数中剔除『0，3，6，9』这些本身就是 3 的倍数的元素，将剩下元素的加和并不会影响我们的判断。就是说正则中的 [0369] 实际上对理清该正则表达式没有帮助，我们暂时忽略正则中所有的 [0369] ，得到如下状态机 我将该状态机与我们开头所设计的状态机对应的状态标记在了图像上，以便于你理解我们推导的正则表达式。 更一般的情况 如和用正则表达式匹配十进制下任意一个整数的倍数呢？ 实际上前面讲述的思路可以用于匹配任一个整数 n 的倍数，我们就需要构造一个有 n 个状态的自动机 在这个状态机中，起始状态和结束状态都是『q0』，第 k 个状态『qk』代表当前读入的数可以被 n 除余 k。我们将手算除法扩展到一般形式： 前面讨论过 m 的范围是 [ 0 - 9 ]，易得通过如下的公式即可构造一条从『qk』到『qr』的转移边 我们需要对每个状态『qk』和 m 的组合都用这个公式计算一遍，这样才可以求得所有的转移边，工作量等于 当然实际编程中我们并不会用这个方法来匹配某一个数的倍数，这里探讨这一问题仅用于拓展思路。 正则表达式如何匹配 3 的倍数？ - Belleve的回答 - 知乎 [https://www.zhihu.com/question/24824487/answer/29109747](https://www.zhihu.com/question/24824487/answer/29109747)">
                <h2><a href="ru-he-yong-zheng-ze-biao-da-shi-pi-pei-3-de-bei-shu.html">如何用正则表达式匹配 3 的倍数</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">问题背景

最近在知乎上看到这样一个问题『如何用正则表达式匹配 3 的倍数』，原帖给出的答案非常有意思，遂研究了一番


看一个数能否被 3 整除，最直接的办法就是将这个数用 3 除一下，如果余数是 0，那么这个数就可以被3 整除。然而正则并不具有计算的功能，正则算法的实现基于有穷状态自动机（finite automaton）


以下是一个简单的示例


这正则表达式 哈+嗝 的自动机，该正则表...</div>
            </div>
            <div class="post-item" data-title="删除或修改 Windows 中被占用的文件" data-content="有时候我们想要在 Windows 中修改或删除一个文件，会收到一个「文件正在使用」的消息，而我们又不知道是哪个程序在使用，这时候该怎么办呢？ 当某一运行中的进程持有一个资源的句柄时，我们就不能修改该资源。解决办法是结束所有对资源有句柄的进程。我们可以在「资源监视器」中找到持有该句柄的所有进程，资源监视器的打开方式如下 - 方法 1： \&lt;Win + R\，运行 resmon.exe - 方法 2： 开始菜单 👉 所有程序 👉 Windiws 管理工具 👉 资源监视器 打开后选中就 CPU ，在「关联的句柄」中输入要释放的文件，即可找到持有该文件按句柄的所有进程，右键结束即可">
                <h2><a href="shan-chu-huo-xiu-gai-windows-zhong-bei-zhan-yong-de-wen-jian.html">删除或修改 Windows 中被占用的文件</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">有时候我们想要在 Windows 中修改或删除一个文件，会收到一个「文件正在使用」的消息，而我们又不知道是哪个程序在使用，这时候该怎么办呢？

当某一运行中的进程持有一个资源的句柄时，我们就不能修改该资源。解决办法是结束所有对资源有句柄的进程。我们可以在「资源监视器」中找到持有该句柄的所有进程，资源监视器的打开方式如下

- 方法 1：

\&lt;Win + R\，运行 resmon.exe

- 方...</div>
            </div>
            <div class="post-item" data-title="初识 JShell" data-content="初识 JShell 升级到 Java 11 后，有了 JShell 这个工具（其实 Java 9 就有了），它让 Java 可以像脚本语言一样直接在命令行交互，听起来好神奇，快来体验一下！！ 启动与退出 保险起见，得先弄明白启动与退出 直接在命令行输入 jshell 就启动了 bash ➜ cedar jshell | Welcome to JShell -- Version 11.0.9.1 | For an introduction type: /help intro jshell 退出方式稍微有一些特别，命令是 /exit bash jshell /exit | Goodbye jshell -h 可以发现提供了几个选项，这仨比较有意思 bash -q Quiet feedback. Same as: --feedback concise -s Really quiet feedback. Same as: --feedback silent -v Verbose feedback. Same as: --feedback verbose 试了一下 -s 非常安静的反馈，看起来真的清爽 bash ➜ cedar jshell -s - int a &#x3D; 1; - int b &#x3D; 2; 初学者还是别整这么安静了，使用 -v 开启详细反馈吧 bash ➜ cedar jshell -v | Welcome to JShell -- Version 11.0.9.1 | For an introduction type: /help intro jshell 简单使用 变量赋值 赋几个值看看 bash jshell int a &#x3D; 1 a &#x3D;&#x3D; 1 | created variable a : int jshell a + 1 $2 &#x3D;&#x3D; 2 | created scratch variable $2 : int jshell $2 + a $3 &#x3D;&#x3D; 3 | created scratch variable $3 : int 可见：没有指定变量的数字会自动赋值给临时变量，我们也可以使用这个临时变量 方法与类 那创建方法呢？ bash jshell String addMark(Word word) { ... return word.val + &quot;!&quot;; ... } | created method addMark(Word), however, it cannot be referenced until class Word is declared 这里方法传入了一个不存在的类，他告诉我们要定义这个类才能使用这个方法，那定义一下吧 bash jshell class Word { ... String val; ... public Word() { ... val &#x3D; &quot;hello word&quot;; ... } ... } | created class Word | update replaced method addMark(Word) 创建个对象调用一下 bash jshell Word words &#x3D; new Word() words &#x3D;&#x3D; Word@2ef1e4fa | created variable words : Word jshell addMark(words) $4 &#x3D;&#x3D; &quot;hello word!&quot; | created scratch variable $4 : String 内置命令 输入 /help 就能看到所有可以使用的命令，例如列出所有变量 bash jshell /vars | Word words &#x3D; Word@2ef1e4fa | String $4 &#x3D; &quot;hello word!&quot; 外部编辑器 有没有觉得在命令行定义类或者方法啥的太费事了，其实 JShell 支持使用编辑器 使用默认编辑器 先定义一个类 bash jshell class Friend{} | 已创建 类 Friend 调用自带的编辑器 bash jshell /edit Friend 如下图，点击 Accept 就行 注意一定是之前定义好的片段，如下： bash jshell /list 1 : int a &#x3D; 1; 2 : int b &#x3D; 2; 3 : int c &#x3D; 1; 6 : class Friend{ String val &#x3D; &quot;No Friend !!!&quot;; } 否则会报错 bash jshell /edit Dog | 没有此类片段: Dog 自定义编辑器 如果想自定义编辑器呢，自带的太不好用 bash jshell /set editor vim | 编辑器设置为: vim bash jshell /set editor &quot;C:\\Users\\cedar\\AppData\\Local\\Programs\\Microsoft VS Code\\code&quot; -w | 编辑器设置为: C:\Users\cedar\AppData\Local\Programs\Microsoft VS Code\code -w 该 -w 选项设置等待文件关闭后再返回 上述设置是一次性的，想永久设置的话，使用 -retain 选项 bash jshell /set editor -retain vim">
                <h2><a href="chu-shi-jshell.html">初识 JShell</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">初识 JShell

升级到 Java 11 后，有了 JShell 这个工具（其实 Java 9 就有了），它让 Java 可以像脚本语言一样直接在命令行交互，听起来好神奇，快来体验一下！！

 启动与退出

保险起见，得先弄明白启动与退出

直接在命令行输入 jshell 就启动了

bash
➜  cedar jshell
|  Welcome to JShell -- Version 11...</div>
            </div>
            <div class="post-item" data-title="VsCode 多光标特性" data-content="使用 VsCode 或者其他编辑器的时候，经常会碰到如下场景: .foo { padding: 5; margin: 5; font-size: 5; } 如何将上面的三个 5 改成 5px ？答案是创建多个光标，以下给出了创建多光标的几种方法： 创建多个光标 1. 使用鼠标 1. 先将将光标置于第一个『5』之后 2. 按住键盘上的 『alt 』,然后鼠标点在第二个“5”之后。那么第二个光标就创建好了。 3. 同样的方法创建第三个光标 2. 使用键盘 1. 将光标置于第一个『5』的那一行 2. 然后按下『Ctrl + Alt + 下方向键』在当前光标下创建新的光标，同样的方法创建的三个光标 3. 按下『Fn + 右方向键』即可切换到行尾（即『End』键） 4. 此时，按下『右方向键』，三个光标都到达了指定位置 注：想要以单词为单位跳转光标，只需按下『Ctrl + 方向键』 相关快捷键 编辑器中还有很多快捷键可以帮助我们快速地创建多光标 1. 『Ctrl + D』 这个命令的作用是，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。 这样，我们只需将光标置于 5 附近，连续按下三次『Ctrl + D』即可选中所有的 5 。此时再按下『右方向键』，输入“px”，即可完成任务。 2. 『Ctrl + Shift + L』 这个命令会选择所有匹配项 1. 选择一个 5 2. 按下『Ctrl + Shift + L』 3. 按下『右方向键』 3. 『Alt + Shift + I』 1. 选择多行代码 2. 然后按下『Alt + Shift + i』，这样操作的结果是：每一行的最后都会创建一个新的光标。">
                <h2><a href="vscode-duo-guang-biao-te-xing.html">VsCode 多光标特性</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">使用 VsCode 或者其他编辑器的时候，经常会碰到如下场景:


.foo {
  padding: 5;
  margin: 5;
  font-size: 5;
}


如何将上面的三个 5 改成 5px ？答案是创建多个光标，以下给出了创建多光标的几种方法：

 创建多个光标

 1. 使用鼠标

1. 先将将光标置于第一个『5』之后

2. 按住键盘上的 『alt 』,然后鼠标点在第二个...</div>
            </div>
            <div class="post-item" data-title="PhotoShop 图层的混合模式是怎么回事" data-content="前言 在修图软件中，调整混合模式就可以将两张照片用不同的风格混合在一起 上图就是将下面这两个图片用不同的混合模式叠加的效果，那么你有没有想过这是什么原理呢？本文就以几个经典的混合模式为例简单研究一下。 图像显示原理 其实各种图层混合模式的灵感就是来源于胶片相机时代。那个时代的摄影师没有先进的计算机来修图，只能拍好胶片后（当然也有其他的感光材料做底片），在暗房通过各种骚操作来给自己的照片添加「特效」，其中很多方法在数字时代就演变成了修图软件中的混合模式。 在修图软件中，图层就是一张张胶片叠在一起，而混合模式就是胶片与胶片之间的药水，不同的药水会让胶片之间产生不同的混合效果。当然要彻底理解修图软件的混合模式就必须得了解 RGB 色彩模型，因为这是混合模式的根基。 YES!!! RGB!! 有谁能不喜欢 RGB 呢。课本上都讲过，光的三原色是红绿蓝，将这三种颜色按照不同的强度和不同的比例混合之后，就可以得到其他的颜色。 计算机也是这样。在计算机中，红绿蓝的比例可以由一组在 [0 - 255] 之间的数据表示，数字越大对应颜色光强越大。就像下图这样，比如我们想显示纯红色，那就让红色的发光强度最大，绿色和蓝色不发光，因此红色就表示为 RGB(255, 0, 0) 如果想显示黄色呢？根据上面的三原色图，只需要让蓝色不发光，红色和绿色发光强度最大，就得到了黄色， 如果让三种颜色第比例相同，那就变成了黑白灰。神奇吧，黑白灰的三原色比例相同，只是发光强度不同。从这个角度看，黑白灰其实是一种颜色，只是亮度不同。所以就不难理解如果想看到真正的「白色」，就必须拼命提高亮度，这也是我们希望显示器亮度更高的原因之一。 当我们把上面的那些颜色块做的非常小，就变成了显示器中像素点。每个都是由红绿蓝三原色组成的，使用程序控制每个像素点的三原色比例，就显示出了不同的图案。下图就是显示器放大的样子。 修图就是计算 到这，你一定能理解，修图软件中的所有操作就是对每个像素点的 RGB 值做计算，比如想要提高一张照片的曝光，那就同时提高每个像素的 RGB 值，这样照片就会变得明亮。如果想提高对比度，那就让较亮的地方的 RGB 更大，较暗的地方 RGB 更小，如下图： 对比度低的照片各像素点的 RGB 值都比较居中，提高对比度后，RGB 值较低（暗）和 RGB 值较高（亮）的像素点变多了。 混合模式也是这个原理，既然是混合，那就得有两个或两个以上的对象。在修图软件中，这样的对象就以图层为载体，我们将两个图层叠放到一起的时候，就会有一个上下对应的关系。上层的一个像素点会对应到下层的一个像素点，混合模式就是对这一组组像素点进行计算。 那么常见的混合模式是怎么计算像素点的呢？ 计算方法 为了计算两张照片的混合，首先要将个像素点 [0 - 255] 的值映射到 [0.00 - 1.00] 的小数区间，比如： - 0 &#x3D; 0.00； - 128 &#x3D; 0.50； - 256 &#x3D; 1.00 也就是每个像素点的三原色值变成了三个小数，这么处理了之后，就比较好计算，那先来两个简单的练练手 「变亮」和「变暗」 这俩操作的公式很简单，分别对比两个像素点的 RGB，变亮就是取大值，变暗就是取小值。 比如有两个像素点：a [84, 164, 109]，b [136, 100, 149] - 变亮：c [136, 164, 149] - 变暗：c [84, 100, 109] 正片叠底 Multiply 什么是正片呢？ : 正片（英语：Positive Film）为底片的分类标准之一，胶片功能类似相纸，利用负片冲印得到正像显影，但不像负片和反转片是摄影胶片； 由于以反转冲洗法（Reversal Process）的反转片（Reversal film）亦采正像显影方式， “正片”遂成与负片相对的感光材料总称，可供影片拷贝、幻灯机及灯箱观赏等用途上，也可印制照片、印刷制版。 可见，正片上的色彩就是图像真实的色彩 [图片来源](https://www.google.com/url?sa&#x3D;i&amp;url&#x3D;https%3A%2F%2Fzh-cn.facebook.com%2Fhi.xikon%2Fposts%2F279712775851997%2F&amp;psig&#x3D;AOvVaw1f4r21n5CgNHNQKHowqq5b&amp;ust&#x3D;1614155052538000&amp;source&#x3D;images&amp;cd&#x3D;vfe&amp;ved&#x3D;2ahUKEwi_8LWlyv_uAhXPCIgKHRkvCTIQjB16BAgAEAg) 那正片叠底就是把两个正片叠上，由于正片亮的地方是透明的，暗的地方是不透明的，叠上之后透明的地方就会显示出另一张正片的图案。 典型示例如下图，上层图层是一个白色背景的水印，下层图层是一个风筝图片，它俩应用正片叠底之后水印的白色背景消失了。 正片叠底的英文是 Mutiply，跟它的名字一样，用公式表示就是：$c&#x3D;a \times b$ 如果刚才那个扣水印的原理你没有看明白，那就用公式解释一下：白色的值是 1，如果 a 是白色，那么混合之后的结果就是 $1 \times b&#x3D;b$，因此水印白色背景被扣掉了。 如果自己跟自己做正片叠底呢？ 那公式就是 $c &#x3D; a ^ 2$ 图像如下，可见整体变暗了一些，亮度低的地方透明度低，变暗的幅度就比较大。 理论上，如果你能在曲线工具中调出一个标准的二次曲线，那它俩效果就是一样的！ 滤色 Screen 正片叠底是堆叠正片，滤色就是堆叠负片，负片就是正片颜色取反。较暗的场景在负片中变得较亮，较亮就意味着透明，叠上之后透明的地方就会显示出另一张负片的图案。 因此如果我们把水印的背景换成黑色，文字换成白色，它俩做滤色，就会得到白色的水印 公式是这样：$C &#x3D; 1-\left(1-a\right)\times\left(1-b\right)$ 也很好理解：$(1 - a)$ 和 $(1 - b)$ 代表 a 和 b 的负片，它俩做堆叠（乘法），最后再冲洗成正片 $(1 - x)$ 自己叠底自己效果如下曲线 $$ \begin{equation} c&#x3D;1-\left(1-a\right)^2 \end{equation} $$ 可见整体偏亮了，同样可以用曲线工具模拟出来： 叠加 Overlay 叠加模式是「正片叠底」和「滤色」的混合模式，是个分段函数。它的公式如下： $$ \begin{equation} f(a, b) &#x3D; \begin{cases} 2ab, &amp; \text{if } a &lt; 0.5 \\ 1 - 2(1-a)(1-b), &amp; \text{otherwise} \end{cases} \end{equation} $$ 其中，a 是底下的图层，b 是上面的图层，就是说 - 当下面像素比较暗的时候，效果相当于两倍正片叠底，导致整体变暗 - 当下面像素比较亮的时候，效果相当于两倍滤色，导致整体变亮 注意观察公式：当其中一个像素某个值是 0.5 的时候（a &#x3D; 0.5 或 b &#x3D; 0.5），另一个像素对应值相当于没变。如果我们拿一个红绿蓝的亮度都是 0.5 的图片，也就是RGB(128,128,128) 和另一个图片做叠加，这个颜色就消失了，再扣个水印试试。 把水印放在下层，在上层应用「叠加」效果，RGB(128,128,128) 就被扣掉了，我来解释一下： - 白色水印部分比较亮，应用的是两倍滤色，前面说滤色会保留白色，因此白色被保留了下来 - 黑色水印部分比较暗，应用的是两倍正片叠底，前面说正片叠底会保留黑色，因此黑色被保留了下来 RGB(128,128,128) 这个颜色叫做中性灰。也就是叠加模式可以扣掉中性灰，这里引申一点，常见的「中性灰修图法」原理就是上面列出的这几点，有兴趣可以去查一下。 那叠加公式这个「两倍」是干嘛的，你说「叠加」是结合了「正片叠底」和「滤色」，那为什么不直接结合，非要弄个两倍呢？ 看一下图像就知道了，由于三维图不好展示，这里还是压缩成二维，也就是自己叠加自己，如果不加两倍直接结合的话会怎么样呢？ 两条曲线在 x &#x3D; 0.5 处根本就是不连续的嘛，这怎么能行呢，所以加上两倍是为了让它俩的图像连续，就下面这样 去掉多余的线条，就是下面这个，是一个增加对比度的曲线： 注意上面这个曲线是自己叠加自己的情况，看起来还是可以用曲线工具模拟出来 总结 图层的混合模式分为几种，就像曲线一样，有的应用了之后会让整体变亮，有的会让整体变暗，有的会增加对比度。 - 「正片叠底」就是一种变暗的模式，混合后最暗的黑色会被保留下来，最亮的白色会被丢弃。 - 「滤色」是一种变亮的模式，混合之后最亮的白色会被保留下来，最暗的黑色会被丢弃。 - 「叠加」是一种增加对比度的模式，它是「正片叠底」和「滤色」的结合体，会扣去中性灰。 混合模式还有很多，但只是函数的曲线略有差别，但是他们的函数复杂，因此就不展开了。如果你有兴趣可以去维基百科上看看 &lt;seealso style&#x3D;&quot;cards&quot; &lt;category ref&#x3D;&quot;external&quot; &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Blend_modes&quot;/ &lt;/category &lt;/seealso">
                <h2><a href="photoshop-tu-ceng-de-hun-he-mo-shi-shi-zen-me-hui-shi.html">PhotoShop 图层的混合模式是怎么回事</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">前言

在修图软件中，调整混合模式就可以将两张照片用不同的风格混合在一起



上图就是将下面这两个图片用不同的混合模式叠加的效果，那么你有没有想过这是什么原理呢？本文就以几个经典的混合模式为例简单研究一下。





 图像显示原理

其实各种图层混合模式的灵感就是来源于胶片相机时代。那个时代的摄影师没有先进的计算机来修图，只能拍好胶片后（当然也有其他的感光材料做底片），在暗房通过各种骚操作来给...</div>
            </div>
            <div class="post-item" data-title="Google 搜索技巧 2" data-content="﹚运算符语法 为了让查询结果更加准确，我们可以在其中加入高级运算符。其基本形式为 operator:search_term ，当你使用高级运算符时，请记住下面的原则： - 运算符、冒号和搜索项之间没有空格 - search_term 部分可能是一个单词或者是一个带引号的短语 - 可以在高级查找中使用布尔运算符（如：OR，+）和其他特殊字符，但注意不要与 : 的功能发生冲突。 - 以 All 开头的运算符通常在每个查询中只能使用一次 &lt;!-- more -- 下面我们来看一些利用高级运算符查询的例子： - eg. intitle:Google 将得到标题中包含单词 Google 的页面 - eg. intitle:&quot;index of&quot; 将得到标题中包含短语 index of 的页面 - 也可以写成 intitle:index.of，因为休止符 . 可以充当任何字符 - eg. intitle:&quot;index of&quot; private 将得到标题中包含短语 index of 和在任意地方出现单词 privae 的页面。 - 任意地方包括 URL、标题、文本等地 - intitle 只对 index of 有效，不包括 private - eg. intitle:&quot;index of&quot; &quot;backup files&quot; 将得到标题中包含短语 index of 和在任意地方出现短语 backup file 的页面 - 同上 ﹚语法排错 Google 会提醒我们在使用高级运算符时犯的语法错误 小提示： 仅限搜索简体中文结果。您可以在设置中指定搜索语言 当然，有时候 Google 也会无能为力 找不到和您查询的“allintitle:food inurl:food”相符的内容或信息。 建议： • 请检查输入字词有无错误。 • 请尝试其他查询词。 • 请改用较常见的字词。 • 请减少查询字词的数量。 有时候 Google 没有识别出语法错误，依然会尝试搜索。当你发现搜索结果页中你输入的运算符被以粗体显示，那很可能就是你犯了语法错误，因为 Google 把他们当成了关键词。 ﹚高级运算符 ◈ intitle 和 allintitle：在页面标题搜索 一个页面的标题大多显示在浏览器的顶部，技术上，它可能是一份 HTML 文档中的 TITLE 标签部分。 二者区别： - intitle 遵守前面提到的语法规则 - intitle:&quot;index of&quot; &quot;backup files&quot; 将得到标题中包含短语 index of 和在任意地方出现短语 backup file 的页面 - allintitle 的作用范围则包括它后边接的全部字符，不要和其他高级运算符混用 建议使用多个 intitle 代替 allintitle，且 intitle 与其他运算符混合使用效果佳 ◈ allintext 在页面文本中查找字符串 allintext 的作用可以概括为「在一个网页文本中找到一个搜索项」或者「除了在标题、URL 和链接里以外，在其他任何地方找到这个字符串」。 由于其作用范围包括它后边的每一个字符，所以 allintext 运算符最好不要和别的高级运算符混用，其实就最好别用这个运算符了。 ◈ inurl 和 allinurl 在一个 URL 中查找文本 - 同样：建议使用多个 inurl 代替 allinurl URL URL 即统一资源定位器（Uniform Resource Locatir）的缩写，一个 URL 就是一个网页的地址。一个普通的 URL 类似俩面这样： https://blog.solidspoon.xyz/54/KaPianLiu/KaPianLiu.html - 其开头通常是 http、ftp 等协议 - eg. http://、https://、ftp://。 - 协议后面是一个路径名地址 - eg. blog.solidspoon.xyz/54/KaPianLiu/ - 最后是一个可选的路径名 - eg. KaPianLiu.html 所以上面示例 URL 的含义：http 表示这基本是一个 web 服务器，服务器位于 blog.solidspoon.xyz，被请求的文件 KaPianLiu.html 能在服务器的 /54/KaPianLiu/ 目录里找到。 ◈ site 把搜索精确到特定的网站 - 使用 site 可以搜索位于一个特定服务器或者一个特定域名里的页面。Google 会从右向左读取 Web 服务器的名字 - eg. site:google.com 会找出所有结尾是 google.com 的网站 - 如果你建设了自己的网站而不确定是否被搜索引擎收录的话，就用这条命令吧，如果显示如下信息，那你最好去搜索引擎提交一下你的网站。 - 可以与其他运算符或搜索项一起使用：是 找不到和您查询的“site:shanlin257.coding.me”相符的内容或信息。 建议： • 请检查输入字词有无错误。 • 请尝试其他查询词。 • 请改用较常见的字词。 ◈ filetype 搜索特定类型的文件 - Google 可以搜索很多不同类型的文件，例如 PDF、微软 Office 文档等。filetype 能够搜索以特定文件名扩展名结尾的页面。 - 可以与其他运算符和搜索项一起使用：是 eg. filetype:doc pirate 点击搜索结果会直接下载文件 ◈ link 搜索一个网页的连接 - link 后接一个 URL 或服务器名，它会搜索那些连接到这个 URL 或服务器的网页 - eg. link:https://mp.weixin.qq.com 会搜索到很多涉及公众号的网页 - 如果语法错误 eg. link:linux Google 会将他作为一个带有冒号的短语来搜索，正确形式为 link:linux.org - 可以与其他运算符或搜索项一起使用：否 ◈ inanchor 在连接描述性文字中寻找文本 eg. 在Google 搜索 inanchor:点击这里 返回的结果页面本身并不一定包含&quot;点击这里&quot;这四个字，而是这些页面里的链接锚文字中出现了&quot;点击这里&quot;这四个字。 我用 HTML 解释一下： &lt;a href&#x3D;&quot;blog.solidspoon.xyz&quot;点击这里&lt;/a ◈ cache 显示页面缓存文本 一个网站必须被搜索引擎爬取过后才会被收录，而搜索引擎在爬取的时候会保存网页快照，即搜索结果页显示的网站摘要。由于互联网上的网站太多了，所以快照不会实时更新，如果你想查看那个版本，就用这个命令把。 eg. cache:blog.solidspoon.xyz 会返回 Google 上一次爬取我的博客时的快照。 ◈ numrange 搜索一个数字 - numrange 命令可以寻找某一范围内的数字,当这个运算符被不坏好意的 Google 骇客利用时，它强大又危险。 - 可以与其他运算符或搜索项一起使用：是 eg. numrange:13-15 会返回含有 13、14 或 15 的网页，你也可以把这个运算符简写为 13..15 ◈ daterange 搜索在特定日期范围内被抓取过的页面 - 一个网页每被抓取一次，这个日期就会改变 - daterange 接受一个日期范围，必须符合 Julian dates 格式，即一个日期自公元前 4713 年 1 月 1 日起经过的天数。 - eg. daterange:2452164-2452164 &quot;osma bin laden&quot; 会返回被 Google 在 2001 年 9 月 11 日索引过并包含短语 Osma Bin Laden 的网页 - 可以直接在 Google 高级搜索页面 https://www.google.com/advanced_search 限制日期 - 可以通过修改 URL 来限制日期 - eg. https://www.google.com/search?q&#x3D;apple&amp;as_qdr&#x3D;m3 会返回过去三个月内被 Google 抓取过的关于 apple 的网页 - 可以与其他运算符或搜索项一起使用：必须 ◈ info 显示 Google 的总结信息 实测还是推荐直接搜索网址比较好 - 可以与其他运算符或搜索项一起使用：是 ◈ related 显示相关站点 - 其后接一个完整的 URL 或主机名 - 与搜索结果页面上的「类似网页」或者高级搜索中的「查找类似网页或相应网页」功能相同。 ◈ stocks 显示股票信息 - 参数为一个有效股票的缩写 - eg. stocks:csc - 可以与其他运算符或搜索项一起使用：否 ◈ defone 显示一个术语的定义 -参数可能是一个单词或短语 ﹚总结 - 除了修改 URL，你还可以使用高级运算符进行查询。高级运算符是 Google 骇客手中强有力的武器。所以你也应该基于这一武器保护你的信息安全。 - 应该避开 all 开头的运算符组合使用 - intitle，inurl，link 分别在标题，URL，网页连接中寻找字符串 - allintext 在文档文本中寻找，它看起来最没用 - filetype 和 site 能够搜索特定的网站或特定的文件类型 - daterange 搜索在特定时间框架内被索引过的文件 - cache、info、related 可以搜索 Google 提供的网页快照，信息摘要，相关网站列表 - stocks 查询某个股票信息 - define 返回一个单词或简单短语的定义">
                <h2><a href="google-sou-suo-ji-qiao-2.html">Google 搜索技巧 2</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">﹚运算符语法

为了让查询结果更加准确，我们可以在其中加入高级运算符。其基本形式为 operator:search_term ，当你使用高级运算符时，请记住下面的原则：

- 运算符、冒号和搜索项之间没有空格
- search_term 部分可能是一个单词或者是一个带引号的短语
- 可以在高级查找中使用布尔运算符（如：OR，+）和其他特殊字符，但注意不要与 : 的功能发生冲突。
- 以 All 开...</div>
            </div>
            <div class="post-item" data-title="Google 搜索技巧 1" data-content="几个网址 可以通过搜索关键字来访问这些页面 1. Google 主页面，大多数搜索的入口 - &lt;a href&#x3D;&quot;https://www.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 1. Google 网上论坛 - &lt;a href&#x3D;&quot;https://groups.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 3. 用 Google 搜索图片和图表 - &lt;a href&#x3D;&quot;https://images.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 4. 从 Google 搜索视频文件 - &lt;a href&#x3D;&quot;https://video.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 6. 高级搜索列表 - &lt;a href&#x3D;&quot;http://www.google.com/advanced_search&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 7. Google 搜索设置 - &lt;a href&#x3D;&quot;https://www.google.com/preferences&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a 8. Google 翻译 - &lt;a href&#x3D;&quot;https://translate.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a &lt;!-- more -- Google 搜索的基本规则 1. Google 查询不区分大小写 2. Google 通配符 - 代表一个单词 3. Google 在一个搜索中会忽略某些通用单词、字母和单个数字 - eg. where 和 how 在某些时候会被忽略 4. Google 搜索最多限制 32 个单词（包含搜索项和高级运算符） 基础搜索 1. 关键词搜索 - eg. Hacker - eg. FBI hacker Mitnick - eg. Mad hacker dpak 2. 短语搜索 - 短语是包含在双引号中的一组的单词，Google 会严格按照你给定的顺序对短语中所有单词进行搜索 - eg. &quot;Google hacker&quot; - eg. &quot;adult huor&quot; - eg. &quot;Carolina gets pwnt&quot; 使用布尔运算符和特殊字符搜索 Google 的布尔运算符包括 AND, OR 和 NOT 1. AND &amp; +：强制搜索某个单词 - Google 默认会自动搜索你查询的所有元素，所以 AND 在 Google 中通常是多余的 - 由于 Google 会忽略一些常用词，如果你要强制搜索他们，可用 +，其后不加空格 - eg. +and just 2. NOT &amp; -：把一个单词排除在搜索之外 - 用 - 可以缩小搜索范围,其后不加空格 - eg. hacker -jacket 3. OR &amp; |：查询只包含其中一个的 - eg. &quot;evil cybercriminal&quot; OR hacker Google URL - Google URL 就是一个指向搜索结果页面的连接，它是动态的，每次访问的结果可能不同。每个 Google 查询都能表示成一个这样的 url，即地址栏显示的那串字符。 - eg. 搜索 &lt;uhacking to zhe gate&lt;/u https://www.google.com/search?q&#x3D;hacking+to+zhe+gate&amp;oq&#x3D;hacking+to+zhe+gate&amp;... 此处省略部分字符 - 其中 www.google.com/search 是 Google 搜索脚本的位置，? 表示紧接着的参数将要被传递到搜索脚本中去 - 参数之间通过与号 &amp; 分离,由变量（Variable）组成，这个变量带着 &#x3D; 以及赋给它的值 www.google.com/search?variable1&#x3D;value&amp;variable2&#x3D;value - 如果搜索中包含特殊字符，它们会被表示成等价的十六进制编码 - 你可以直接修改 URL 来搜索你想要的东西或者通过访问 Google 高级搜索界面 www.google.com/advanced_search 来设置各种参数 关于 URL 编码 - 通常如果一样东西需要编码，说明这样东西并不适合传输。原因多种多样，如 Size 过大，包含隐私数据，对于Url来说，之所以要进行编码，是因为Url中有些字符会引起歧义。 - URL 编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 - Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_. 4 个特殊字符以及所有保留字符。 - URL 的编码方式非常简单，使用 % 百分号加上两位十六进制字符（因此也称百分号编码），Url编码默认使用的字符集是 US-ASCII - eg. 空格 » %20 总结 Google 简单的外表下提供了很多强大的功能选项，你可以用它来实现强有力的搜索。你可以搜索很多类型的内容，比如 Web 页面、新闻论坛、图片、视频等等。可以用 -, | 等代替布尔运算符，Google 自动包含一个搜索里的所有搜索项，所以 AND 运算符通常是被忽略的。可以通过访问高级搜索页面填写高级搜索项，可以使用高级搜索来快速缩小搜索范围。随着经验的增多，你就能更快的找到你想要的。">
                <h2><a href="google-sou-suo-ji-qiao-1.html">Google 搜索技巧 1</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">几个网址
可以通过搜索关键字来访问这些页面

1. Google 主页面，大多数搜索的入口
    - &lt;a href&#x3D;&quot;https://www.google.com&quot; target&#x3D;&quot;blank&quot;https://www.google.com&lt;/a
1. Google 网上论坛
    - &lt;a href&#x3D;&quot;https://groups.google.com&quot; target&#x3D;&quot;blank&quot;http...</div>
            </div>
            <div class="post-item" data-title="Git 是纯函数式数据结构" data-content="最近一直在学习 Git，但是一直不知道它的原理是什么，直到看到国外的一个大牛的博客。这篇博文给了我很大的启发，所以翻译过来和大家分享。 [原文链接](https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/) 虽然近几年像 Git 这种分布式版本管理系统很火，但它看起来还是比像 SVN 这样的集中式版本控制系统复杂。我猜这可能是因为我们总是会把二者相比较：在 SVN 中这样做，但在 Git 中却需要那样做。 我认为 Git 的真实含义应该是一个纯粹的函数式据结构。所以，如果你在学习熟练地使用 Git，那你也就是在学习处理数据结构。那么我们就先来探讨一下纯函数式数据结构。 不变性 函数式编程中一个很重要的概念就是不变性( immutablity )。就是说一个对象的状态在构造完成以后不可改变 比如有一个典型列表 [3,2,1]。如果这个列表是可变的，我们可以在他的头部插入一个元素4，即 [4,3,2,1]。现在它变成了一个全新的列表，之前的那个列表丢失了。如果此时其他的小伙伴也在操作这个列表，他们便会不幸地得到一个异常. 而函数式编程便不会发生这种情况。因为当我们在列表头部插入 4 时，它会创建一个新列表 [4,3,2,1]，而不会修改原始列表。所以两个列表会同时存在。 可是如果我们每次迭代这个列表都会生成一个全新的列表，这样不仅浪费，而且效率很低啊。 实际上，函数式数据结构的效率在很大程度上取决于对它们执行的操作。对于刚刚那种（单链接）列表，如果我们只是想在它的头部插入数据，完全可以用更有效率的方法： +---+ +---+ +---+ +---+ | 4 +---+ 3 +---+ 2 +---+ 1 | +---+ +---+ +---+ +---+ | | new list original 我们将新元素 4 放在一个新节点中，并将它指向列表的其余部分。你看，之前的列表得到了复用，之前我们发现的那些问题全都解决了。 可是如果其他人想要在 [3,2,1] 之前插入 9 呢？当然也可以用这个方法啦： +---+ +---+ +---+ +---+ new list 1 - | 4 +---+-+ 3 +---+ 2 +---+ 1 | +---+ / +---+ +---+ +---+ / | +---+/ original new list 2 - | 9 + +---+ 我们当然也可以将这样的元素存储为可变列表（non-immutable list），但是这很危险。假如我们更新列表中的元素 [3]，那部分可是公共的，你的修改会影响到他人，那些需要 [9,3,2,1] 列表的人可不喜欢你这么干。 但是......如果我确实需要将元素 3 变成 5，该怎么办？还是用老方法啊： +---+ +---+ updated list - | 4 +---+ 5 + +---+ +---+\ \ +---+ +---+ \ +-+-+ +---+ new list 1 - | 4 +---+ 3 +---+ 2 +---+ 1 | +---+ / +---+ +---+ +---+ / | +---+/ original new list 2 - | 9 + +---+ 你看，它现在可以表示四个列表： - 最初的的列表 [3,2,1] - list 1 [4,3,2,1] - list 2 [9,3,2,1] - list 2 [4,5,2,1] 纯函数数据结构在多线程编程中非常有用，因为来自不同线程的更改不会相互干扰。 和 Git 的关系 可是，我们之前讨论的不变性和 Git 的版本控制功能有什么关系呢？那我们就一起来对比以下它们俩的异同吧。 - 在版本控制系统中我们想要完成的是： 1. 使用新版本的文件更新我们的代码仓管库，旧版本文件也要保留。 2. 当你和你的小伙伴门在同一个个代码库上进行协作时，不会以不可预测的方式相互干扰。 - 不可变的数据结可以： 1. 更新数据结构的同时保留老的数据结构。 2. 在一个线程中对数据结构更改不会影响到其他线程 怎么样，是不是觉得它们俩很像。 事实上，我门甚至可以说 Git 基本上就是是一个纯粹的函数式数据结构，让你使用命令行客户端在其上执行操作。 要完成这个类比，我们需要把上面的数字替换成 Commit。 Git commints 是工作历史中特定时间点的全部工作状态的独立副本，即工作目录的完整快照。我们可以把示例中的链表看成是 Git 中的历史记录。 比如说我们有一个代码仓库，它的 master 分支包含三个按顺序的 commit : A，B，C。也就是我们让 Git 在整个开发过程中完整地存储了我们的工作目录三次。 这就是历史纪录啊，用图说话： +---+ +---+ +---+ + C +---+ B +---+ A | +---+ +---+ +---+ | master Git commit 当我们执行 commit 的时候，这就可以类比成我们将一个数据提交到了这个历史纪录的开头。而 Git 甚至用 HEAD 代表当前的 commit。 +---+ +---+ +---+ +---+ + D +---+ C +---+ B +---+ A | +---+ +---+ +---+ +---+ | | master master^ 当 Git 执行 commit 时，它会移动当前分支指针，将 master 指向 [D,C,B,A]。我们仍然 可以通过名称 master^ 指向 [C,B,A]，并且不会影响到其他人。 Git amend 如果你使用过 Git，你或许知道可以使用 commit --amend 来更新最近一次的 commit ，但你真的可以更新 commit 吗？ 事实上，你不能。Git 只是创建一个新的 commit （下图中 E）并将 branch 指针指向它。你仍然可以使用 git reflog 命令看到它，并且可以通过它的 hash value 来引用（假设他的 hash value 是 ef4d34）。 +---+ +---+ +---+ +---+ ef4d34 - | D +--++ C +---+ B +---+ A | +---+ / +---+ +---+ +---+ / | +---+ master^ master - | E | +---+ Git branch 如你所见，每次执行 commit --amend 时，实际上都会创建一个新分支。分支的唯一功能就是给我们能引用的 commit 起个名字。我们甚至可以使用 git checkout -b branch ef3d34 命令在那个被丢弃的 commit ef3d34 上创建一个新分支。 +---+ +---+ +---+ +---+ branch - | D +--++ C +---+ B +---+ A | +---+ / +---+ +---+ +---+ / | +---+ master^ master - | E | +---+ 通常，我们通过为当前的工作流 HEAD 创建一个新名称来在 Git 中进行分支，但是如果你将 Git 理解为一个函数式数据结构，你就可以随心所欲地在这个树状图上的任何一个 commit 上创建分支了。 Git rebase 当我们在上边的示例列表中更新一个节点时,我们必须把列表中的每个节点添加到在更新后的元素之前（在我们的示例中，这是单个节点 4，但可以是任意数量的节点）。在 Git 中，这称为重新提交（replaying commits），执行此操作的命令称为变基（rebase）。要更新旧提交，我们添加 -i 参数来执行一个在 Git 中称被叫做「交互式 rebase」的操作。 比如说，我们想要用一个新的 commit message 来更新 commit C。我们需要切换到 commit D，然后输入 git rebase -i c 。 git checkout D git rebase -i C 在窗口中包含一下内容： pick cd3ff32 &lt;C&#x27;s commit message pick a65a671 &lt;D&#x27;s commit message some helpful comments from git 如果我们想编辑 cimmit C，Git 允许我们在重放后续提交之前编辑该提交。 edit cd3ff32 &lt;C&#x27;s commit message pick a65a671 &lt;D&#x27;s commit message 当我们保存文件并关闭它时，Git 会开始一个 rebase 。它会在 commit C 停止，这样我们可以修改它。 Stopped at cd3ff32... &lt;C&#x27;s commit message You can amend the commit now, with git commit --amend Once you are satisfied with your changes, run git rebase --continue 窗口中的消息说明了一切。我们可以根据需要随意编辑 commit 后我们调用 commit --amend 创建更新的 commit，然后使用「继续 rebase」指令： git rebase --continue。 当我们选择命令时，其余的 commit 将一个接一个地重放 pick（除非最终发生了合并冲突，在这种情况下 Git 会停止并在你修复它之后才能继续）。我们的完整存储库现在就像下边这样。 +---+ +---+ rebased -| D&#x27;+---+ C&#x27;+ +---+ +---+ +---+ +---+ +---+ +---+ branch - | D +--++ C +---+ B +---+ A | +---+ / +---+ +---+ +---+ / | +---+ master^ master - | E | +---+ 我希望上面的图会让你觉得熟悉。希望你也能明白为什么 Git 的 rebase 命令会创建所有新的 commit。Git 是一个函数式数据结构，它不允许更改现有的 commit。 由于 rebase 引入了一个新的提交链，所以我们一定希望能够对这个新链的外观进行必要的且任意的控制。我们可以用 rebase -i 来重新排序，压缩或删除提交，或者随意拉入新的提交，比如把一个 commit 分成几部分，或者从存储仓库中的其他位置开始（使用 --onto 参数）。 Git merge 现在我们来谈谈合并把。Git 允许我们将两个分支合并为一个 +---+ --+ X | +---+/ +---+ | M | +---+ +---+ --+ Y | +---+ 合并給我们的模型带来了更多的复杂性。它把我们的历史从一个树状图变成了一个非循环图。这并没有太大的改变，但请注意，虽然 rebase 听起来复杂，但只有 merge 命令带来了额外的概念复杂性。 可以通过在新方向上应用新提交来理解 Rebase 。合并是一种根本不同的操作。一个数据结构，一个你可以将两个部分像这样组合成数据结构一个特殊的名称：我们称它 confluently persistent。（函数式数据结构也叫 persistent。我避免使用 这个术语，所以你不要将它与像物理光盘这样的持久性媒体上的存储概念混淆。） 结论 Git可以看成是一个相当简单的函数式数据结构。与其把Git描述成一个版本控制系统，不如说版本控制是“不变性”数据结构的一个自然属性。。我认为以这种方式谈论 Git 能更准确地传达 Git 的简单性和威力，而不是与集中式版本控制系统相比能完成什么。 如果以这种方式来思考的话，Git 在概念上比 SVN, CVS 等要简单。 大家认为 Git 更加复杂可能是因为这种复杂性能支持更有趣的 workflow。 如果你曾经觉得 Git 令人生畏，那请记住它的简单结构，以及在函数式结构中， 插入其中的任何东西都不会真正丢失，并且可以被恢复。（检查你的 reflog）">
                <h2><a href="git-shi-chun-han-shu-shi-shu-ju-jie-gou.html">Git 是纯函数式数据结构</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">最近一直在学习 Git，但是一直不知道它的原理是什么，直到看到国外的一个大牛的博客。这篇博文给了我很大的启发，所以翻译过来和大家分享。

 [原文链接](https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/)

虽然近几年像 Git 这种分布式版本管理系统很火，但它看起来还是比像 SVN 这样的集...</div>
            </div>
            <div class="post-item" data-title="Docker 诊断神器 BusyBox" data-content="BusyBox 是一个集成了一百多个最常用 Linux 命令和工具（如 cat、echo、grep、mount、telnet 、ping、ifconfig 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。 BusyBox 容器镜像可以帮助我们快速测试容器网络 直接运行并进入命令行： bash docker run --name &lt;my-docker-name -it --rm busybox sh --rm 参数可以让我们在退出容器时自动销毁该容器 创建时指定网络 bash docker run -it --rm --name &lt;my-docker-name --network &lt;my-net busybox sh 将一个容器连接到网络 bash docker network connect &lt;my-net &lt;my-docker-name 将容器从网络断开 bash docker network disconnect &lt;my-net &lt;my-docker-name">
                <h2><a href="docker-zhen-duan-shen-qi-busybox.html">Docker 诊断神器 BusyBox</a></h2>
                <div class="post-date">2021-02</div>
                <div class="excerpt">BusyBox 是一个集成了一百多个最常用 Linux 命令和工具（如 cat、echo、grep、mount、telnet 、ping、ifconfig 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。



BusyBox 容器镜像可以帮助我们快速测试容器网络


直接运行并进入命令行：
bash
docker run --name &lt;...</div>
            </div>
        </div>
    </div>
    <footer class="blog-footer">
        <div class="footer-content">
            <p class="footer-motto">方向是比速度更重要的追求</p>
        </div>
    </footer>    <script>
        // 准备搜索数据
        const posts = Array.from(document.querySelectorAll('.post-item')).map((item, idx) => ({
            id: idx,
            title: item.dataset.title,
            content: item.dataset.content,
            element: item,
            originalIndex: idx  // 保存原始顺序
        }));

        // 保存原始顺序
        const originalOrder = posts.map(post => post.element);

        // 搜索功能 - 增强的grep风格搜索
        const searchInput = document.getElementById('searchInput');
        const postsContainer = document.getElementById('postsContainer');

        searchInput.addEventListener('input', (e) => {
            const query = e.target.value.trim().toLowerCase();

            // 如果搜索框为空，恢复原始顺序和显示所有文章
            if (query.length < 2) {
                posts.forEach(post => {
                    post.element.classList.remove('search-highlight');
                    post.element.style.borderLeftWidth = '';
                    post.element.style.borderLeftColor = '';
                });

                originalOrder.forEach(element => {
                    postsContainer.appendChild(element);
                });

                return;
            }

            // 1. 整体搜索词
            const fullQuery = query;
            
            // 2. 分词搜索 - 按空格分割
            const queryTerms = query.split(/\s+/).filter(term => term.length >= 2);
            
            // 计算每篇文章的匹配分数
            const scoredPosts = posts.map(post => {
                const lowerTitle = post.title.toLowerCase();
                const lowerContent = post.content.toLowerCase();
                let score = 0;
                
                // 完整查询匹配得分（优先级最高）
                if (lowerTitle.includes(fullQuery)) {
                    score += 100; // 标题中完整匹配得高分
                }
                if (lowerContent.includes(fullQuery)) {
                    score += 50;  // 内容中完整匹配得分
                }
                
                // 分词匹配得分
                queryTerms.forEach(term => {
                    if (lowerTitle.includes(term)) {
                        score += 20; // 标题中有单个词匹配
                    }
                    if (lowerContent.includes(term)) {
                        score += 10; // 内容中有单个词匹配
                    }
                });
                
                return {
                    post,
                    score
                };
            });
            
            // 分离匹配和不匹配的文章
            const matchedPosts = scoredPosts
                .filter(item => item.score > 0)
                .sort((a, b) => b.score - a.score); // 匹配的按分数排序
                
            const unmatchedPosts = scoredPosts
                .filter(item => item.score === 0)
                .sort((a, b) => a.post.originalIndex - b.post.originalIndex); // 不匹配的按原始顺序排序
            
            // 更新文章样式
            posts.forEach(post => {
                const matchResult = scoredPosts.find(item => item.post.id === post.id);
                if (matchResult && matchResult.score > 0) {
                    // 匹配文章，添加高亮
                    post.element.classList.add('search-highlight');
                    // 添加额外的高亮强度，与分数相关
                    const intensity = Math.min(100, matchResult.score) / 100;
                    post.element.style.borderLeftWidth = `${3 + intensity * 4}px`;
                    post.element.style.borderLeftColor = '#0969da';
                } else {
                    // 不匹配文章，移除高亮
                    post.element.classList.remove('search-highlight');
                    post.element.style.borderLeftWidth = '';
                    post.element.style.borderLeftColor = '';
                }
            });
            
            // 先添加匹配的文章，后添加不匹配的文章
            const sortedResults = [...matchedPosts, ...unmatchedPosts];
            sortedResults.forEach(item => {
                postsContainer.appendChild(item.post.element);
            });
        });
    </script>
</body>

</html>
